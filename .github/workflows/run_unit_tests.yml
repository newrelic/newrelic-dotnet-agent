name: .NET Agent Unit Tests and Code Coverage

# Does not run on PUSH since we have already ran all the test
on:
  push:
    branches: 
    - 'tippmar-nr**'

env:
  scripts_path: ${{ github.workspace }}\build\scripts
  tools_path: ${{ github.workspace }}\build\Tools
  DOTNET_NOLOGO: true

jobs:

  run-unit-tests:
    name: Run Unit Tests
    runs-on: windows-latest

    env:
      fullagent_solution_path: ${{ github.workspace }}\FullAgent.sln

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup .NET Core
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 7.x
          dotnet-quality: 'ga'

      #- name: Setup MSBuild
      #  uses: microsoft/setup-msbuild@v1

      #- name: Setup VSTest Path
      #  uses: darenm/Setup-VSTest@v1

      #- name: Build FullAgent.sln
      #  run: |
      #    Write-Host "List NuGet Sources"
      #    dotnet nuget list source # For unknown reasons, this step is necessary to avoid subsequent problems with NuGet package restore
      #    Write-Host "MSBuild.exe -restore -m -p:Configuration=Release -p:AllowUnsafeBlocks=true" ${{ env.fullagent_solution_path }}
      #    MSBuild.exe -restore -m -p:Configuration=Release -p:AllowUnsafeBlocks=true ${{ env.fullagent_solution_path }}
      #  shell: powershell

      #- name: Unit Tests
      #  run: |
      #    Write-Host "Creating TestResults directory to temporarily get around nunit limitation"
      #    mkdir ${{ github.workspace }}\TestResults

      #    $testDllPatterns = @('*Tests.dll', '*Test.dll', '*Test.Legacy.dll')
      #    Write-Host "Finding files for Framework NUnit tests"
      #    $frameworkTestPaths = @('Tests\Agent\UnitTests', 'Tests\NewRelic.Core.Tests')
      #    $frameworkTestFileNames = (Get-ChildItem -Recurse -Path $frameworkTestPaths -Include $testDllPatterns | Where-Object { !$_.FullName.Contains('obj\Release') } | Select Name -Unique)
      #    $frameworkFiles = (Get-ChildItem -Recurse -Path $frameworkTestPaths -Include $testDllPatterns | Where-Object { !$_.FullName.Contains('obj\Release')  })

      #    Write-Host "Building file list for Framework NUnit tests"
      #    $frameworkUnitTestPaths = @()
      #    for ($i = 0; $i -lt $frameworkTestFileNames.Length; $i++)
      #    { $frameworkFiles | ForEach-Object { if ($_.Name -eq $frameworkTestFileNames[$i].Name) { $frameworkUnitTestPaths += $_.FullName; Continue } } }

      #    $frameworkUnitTestPaths | ForEach-Object { $_ }
      #    Write-Host "Executing: vstest.console.exe " $frameworkUnitTestPaths " --parallel --logger:'html;LogFileName=agent-results.html' --collect:'XPlat Code Coverage' /testadapterpath:$env:USERPROFILE\.nuget\packages\coverlet.collector\3.2.0\build\netstandard1.0"
      #    vstest.console.exe $frameworkUnitTestPaths --parallel --logger:"html;LogFileName=agent-results.html" --collect:"XPlat Code Coverage" /testadapterpath:$env:USERPROFILE\.nuget\packages\coverlet.collector\3.2.0\build\netstandard1.0

      #    if ($LastExitCode -ne 0)
      #    { exit $LastExitCode }

      #    Write-Host "Finding files for .NET Core NUnit tests"
      #    $netCoreTestFileNames = (Get-ChildItem -Recurse -Path 'Tests\AwsLambda\UnitTests' -Include $testDllPatterns | Where-Object { !$_.FullName.Contains('obj\Release') } | Select Name -Unique)
      #    $netCoreFiles = (Get-ChildItem -Recurse -Path 'Tests\AwsLambda\UnitTests' -Include $testDllPatterns | Where-Object { !$_.FullName.Contains('obj\Release')  })

      #    Write-Host "Building file list for .NET Core NUnit tests"
      #    $netCoreUnitTestPaths = @()
      #    for ($i = 0; $i -lt $netCoreTestFileNames.Length; $i++)
      #    { $netCoreFiles | ForEach-Object { if ($_.Name -eq $netCoreTestFileNames[$i].Name) { $netCoreUnitTestPaths += $_.FullName; Continue } } }

      #    Write-Host "Executing .NET Core NUnit Tests:"
      #    $netCoreUnitTestPaths | ForEach-Object { $_ }
      #    Write-Host "Executing: dotnet test " $netCoreUnitTestPaths " --logger:'html;LogFileName=lambda-results.html' --collect:'XPlat Code Coverage'  /testadapterpath:$env:USERPROFILE\.nuget\packages\coverlet.collector\3.2.0\build\netstandard1.0"
      #    dotnet test $netCoreUnitTestPaths --logger:"html;LogFileName=lambda-results.html" --collect:"XPlat Code Coverage"  /testadapterpath:$env:USERPROFILE\.nuget\packages\coverlet.collector\3.2.0\build\netstandard1.0

      #    if ($LastExitCode -ne 0)
      #    { exit $LastExitCode }
      #  shell: powershell

      #- name: Upload coverage reports to Codecov.io
      #  uses: codecov/codecov-action@v3
      #  with:
      #      directory: TestResults

      #- name: Archive Test Results
      #  if: ${{ always() }}
      #  uses: actions/upload-artifact@v2.2.4
      #  with:
      #    name: test-results
      #    path: ${{ github.workspace }}\TestResults
      #    if-no-files-found: error


      - name: Install dependencies
        run: dotnet restore -f
      - name: Build & Test (only builds unit test projects and their dependencies)
        run: dotnet test --no-restore --verbosity normal --collect:"XPlat Code Coverage"  --results-directory TestResults --settings tests\CodeCoverage.runsettings

      - name: Upload coverage reports to Codecov.io
        uses: codecov/codecov-action@v3
        with:
            directory: TestResults

      #- name: ReportGenerator
      #  uses: danielpalme/ReportGenerator-GitHub-Action@5.1.14
      #  with:
      #    reports: '**/TestResults/**/coverage.cobertura.xml'
      #    targetdir: 'coveragereport'
      #    reporttypes: 'Html;MarkdownSummaryGithub;PngChart'
      #    historydir: 'code-coverage-history'
      #    filefilters: '-*/Tests/*'
      #    title: 'New Relic .NET Agent Code Coverage'
      #- name: Upload coverage report artifact
      #  uses: actions/upload-artifact@v2.2.3
      #  with:
      #      name: CoverageReport # Artifact name        
      #      path: coveragereport # Directory containing files to upload
