// Copyright 2020 New Relic, Inc. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Linq;
using System.Linq.Expressions;
using System.Net.Http;
using System.Reflection;
using NewRelic.Agent.Configuration;
using NewRelic.Agent.Core.DataTransport;
using NewRelic.Agent.Core.Events;
using NewRelic.Agent.Core.Logging;
using NewRelic.Agent.Core.Utilities;
using NewRelic.Agent.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Exporter;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;

namespace NewRelic.Agent.Core.OpenTelemetryBridge
{
    // This class is used as a bridge between the DiagnosticSource library included with an application, and the version of the DiagnosticSource library
    // and OpenTelemetrySDK included with the New Relic agent. This allows the customer's application to use a different version of the DiagnosticSource
    // library than the agent, and still have the agent collect metrics from the application's instruments. This approach allows us to handle scenarios
    // where it is not possible for the agent to force a newer version of the DiagnosticSource library to load, which can happen when an older version
    // of the DiagnosticSource library is included in the application's working directory (or build output).
    //
    // This solution works by including an ILRepacked version of the DiagnosticSource library in the agent. The agent can directly reference the code in
    // the ILRepacked library. In this documentation we will refer to the ILRepacked types as Meter', Instrument', Measurement', etc. The "'" character
    // is used to indicated that we are talking about an ILRepacked type. The types available in the customer's application will not have the "'" suffix.
    //
    // To collect metric data from the Metrics API, you need to create a MeterListener. MeterListeners operate in a pub-sub model where MeterListeners
    // subscribe to Instruments published by Meters. When an Instrument is published, the MeterListener will subscribe to the Instrument and listen for
    // measurements. When measurements are recorded on the Instrument, the MeterListener will receive the measurements and process them as necessary.
    // If there are no listeners for an Instrument the measurements for that instrument will be dropped and not stored anywhere. Because of the way
    // this pub-sub model is implemented, a MeterListener' (an ILRepacked MeterListener) instance cannot subscribe to data generated by a Meter (from
    // the customer's application) instance. The pub-sub model relies on static fields linking MeterListeners to Meters and so the ILRepacked MeterListeners
    // can only see ILRepacked Meters. To workaround this, we need to build a MeterListener dynamically at runtime using the MeterListener type from the
    // customer's application. This will allows us to forward the data from the types in the customer's application to the ILRepacked types in the agent.
    //
    // We use a combination of reflection and expression trees to build the MeterListener at runtime. The solution works by recreating all Meters,
    // Instruments, and Measurements in the customer's application using the ILRepacked types. The MeterListener class provides 3 main hooks that we
    // leverage to bridge the data between the 2 library versions.
    //
    // 1. InstrumentPublished: This event is triggered when an Instrument is published by a Meter. We subscribe to this event and create a bridged
    //     version of the Meter and Instrument and copying all of the available data over to Meter' and Instrument'.
    // 2. MeasurementEventCallback: This event is triggered when a measurement is recorded on an Instrument. We subscribe to this event and forward
    //     the measurement as a bridged Measurement' to the bridged Instrument'. We use the state parameter to store the bridged Instrument' instance
    //     so that we do not need to maintain our own dictionary to manage the mapping.
    // 3. MeasurementsCompleted: This event is triggered when an Instrument is no longer being subscribed to by a MeterListener or the Meter holding
    //     the instrumented is Disposed. In our use case, we subscribe to all instruments in a meter and do not disable individual instruments, so
    //     the only way this event will be triggered is if the corresponding meter is no longer being used by the application or if our MeterListener
    //     is being Disposed. In either case we can just Dispose of the bridged Meter', which will clean up all of our bridged Instrument' instances.
    //
    // Observable Instruments require special handling, because the values for Observable Instruments are not recorded directly on the Instrument, because
    // they rely on a Pull-based model. This pull typically happens when someone wants to export the metric data somewhere. In order to handle Observable
    // Instruments, we create a callback on the bridged observable Instrument' that will call the internal Observe() method on the original Instrument
    // to retrieve an IEnumerable<Measurement<T>> collection, that we can use to create a bridged IEnumerable<Measurement<T>'> collection returned by
    // our callback. As a result, we do not rely on our MeterListener triggering the collection of all observable Instruments, and then forwarding the
    // data using the MeasurementEventCallback. We instead rely on the OpenTelemetry Exporter configured using the OpenTelemetry SDK to trigger the
    // collection of bridged observable Instruments', which will run our registered callbacks that bridge the data from the original observable
    // Instruments.
    public class MeterListenerBridge : ConfigurationBasedService
    {
        private dynamic _meterListener;
        private static Meter NewRelicBridgeMeter = new Meter("NewRelicOTelBridgeMeter");
        private static ConcurrentDictionary<string, Meter> _bridgedMeters = new ConcurrentDictionary<string, Meter>();
        private static ConcurrentDictionary<Type, object> _createInstrumentDelegates = new ConcurrentDictionary<Type, object>();
        private static ConcurrentDictionary<Type, object> _bridgeMeasurementDelegates = new ConcurrentDictionary<Type, object>();
        private static ConcurrentDictionary<Type, ObservableInstrumentCacheData> _createObservableInstrumentCache = new ConcurrentDictionary<Type, ObservableInstrumentCacheData>();

        private OpenTelemetrySDKLogger _sdkLogger;
        private MeterProvider _meterProvider;
        private IConnectionInfo _connectionInfo;

        // Configuration constants for OTLP export
        private const int DefaultOtlpTimeoutSeconds = 10;
        private const int DefaultOtlpExportIntervalSeconds = 5;

        public MeterListenerBridge()
        {
            _subscriptions.Add<AgentConnectedEvent>(OnAgentConnected);
            _subscriptions.Add<PreCleanShutdownEvent>(OnPreCleanShutdown);
        }

        private void OnAgentConnected(AgentConnectedEvent agentConnectedEvent)
        {
            Stop();
            _connectionInfo = agentConnectedEvent.ConnectInfo;
            Start();
        }

        private void OnPreCleanShutdown(PreCleanShutdownEvent preCleanShutdownEvent)
        {
            Stop();
        }

        protected override void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource)
        {
            // Nothing to do here, but this abstract method must be implemented.
            // The real work will start once the agent is connected.
        }

        /// <summary>
        /// Starts the meter listener bridge to begin collecting and forwarding metrics.
        /// Initializes the OpenTelemetry SDK, configures OTLP export, and sets up the MeterListener.
        /// </summary>
        public void Start()
        {
            if (!_configuration.OpenTelemetryEnabled)
            {
                Log.Debug("OpenTelemetry Meter Bridge is disabled via global OpenTelemetry configuration.");
                return;
            }

            if (!_configuration.OpenTelemetryMetricsEnabled)
            {
                Log.Debug("OpenTelemetry Meter Bridge is disabled via metrics-specific configuration.");
                return;
            }

            if (_connectionInfo == null)
            {
                Log.Debug("OpenTelemetry Meter Bridge cannot start: connection info not available.");
                return;
            }

            if (_sdkLogger == null)
            {
                _sdkLogger = new OpenTelemetrySDKLogger();
            }

            if (_meterProvider == null)
            {
                var uriBuilder = new UriBuilder(_connectionInfo.HttpProtocol, _connectionInfo.Host, _connectionInfo.Port, "/v1/metrics");



                var providerBuilder = Sdk.CreateMeterProviderBuilder()

                .ConfigureResource(r => r
                    .AddService(_configuration.ApplicationNames.First())
                    .AddTelemetrySdk()
                    .AddAttributes([new KeyValuePair<string, object>("entity.guid", _configuration.EntityGuid)]))
                .AddMeter("*")
                .AddOtlpExporter((exporterOptions, metricReaderOptions) =>
                {
                    exporterOptions.Endpoint = uriBuilder.Uri;
                    exporterOptions.Protocol = OtlpExportProtocol.HttpProtobuf;
                    exporterOptions.Headers = $"api-key={_configuration.AgentLicenseKey}";

                    // Configure HttpClient factory with proxy and retry logic
                    exporterOptions.HttpClientFactory = CreateHttpClientWithProxyAndRetry;

                    // TODO: Determine if we still need this code block
#if NETSTANDARD2_0_OR_GREATER
                    // Additional .NET Standard specific configurations can go here if needed
#endif
                    // Configure metric collection and export settings
                    metricReaderOptions.PeriodicExportingMetricReaderOptions.ExportIntervalMilliseconds = DefaultOtlpExportIntervalSeconds * 1000;
                    metricReaderOptions.TemporalityPreference = MetricReaderTemporalityPreference.Delta;

                });

                _meterProvider = providerBuilder.Build();
            }

            if (_meterListener == null)
            {
                try
                {
                    TryCreateMeterListener();
                }
                catch (Exception ex)
                {
                    Log.Warn(ex, "Failed to create MeterListener");
                }
                _meterListener?.Start();
            }
        }

        /// <summary>
        /// Creates an HttpClient configured with proxy settings and retry logic appropriate for the target framework.
        /// </summary>
        /// <returns>HttpClient configured for OTLP export</returns>
        private HttpClient CreateHttpClientWithProxyAndRetry()
        {
            try
            {
                // Create base HttpClientHandler with proxy configuration
                var httpClientHandler = new HttpClientHandler();

                // Configure proxy if available
                if (_connectionInfo?.Proxy != null)
                {
                    Log.Debug($"Configuring OTLP exporter with proxy: {_connectionInfo.Proxy}");
                    httpClientHandler.Proxy = _connectionInfo.Proxy;
                    httpClientHandler.UseProxy = true;
                }
                else
                {
                    Log.Debug("No proxy configured for OTLP exporter");
                    httpClientHandler.UseProxy = false;
                }

#if NETSTANDARD2_0_OR_GREATER
                // For .NET Standard 2.0+: Add retry logic with exponential backoff and audit logging
                var retryHandler = new CustomRetryHandler
                {
                    InnerHandler = httpClientHandler
                };

                // Wrap the retry handler with audit logging for OTLP compliance
                var auditHandler = new OtlpAuditHandler
                {
                    InnerHandler = retryHandler
                };

                var httpClient = new HttpClient(auditHandler);
#else
                // For .NET Framework: Direct HttpClient with audit logging wrapper
                // (CustomRetryHandler uses async/await patterns that work better in .NET Standard)
                var auditHandler = new OtlpAuditHandler
                {
                    InnerHandler = httpClientHandler
                };

                var httpClient = new HttpClient(auditHandler);
#endif

                // Configure timeout (OTEL default is 10 seconds)
                httpClient.Timeout = TimeSpan.FromSeconds(DefaultOtlpTimeoutSeconds);

                // Add User-Agent for New Relic identification
                httpClient.DefaultRequestHeaders.Add("User-Agent",
                    $"NewRelic-DotNet-Agent/{AgentInstallConfiguration.AgentVersion ?? "Unknown"}");

                return httpClient;
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Failed to create HttpClient for OTLP exporter. Falling back to default HttpClient.");
                return new HttpClient();
            }
        }

        /// <summary>
        /// Stops the meter listener bridge and disposes of all resources.
        /// Cleans up the MeterListener, MeterProvider, and SDK logger.
        /// </summary>
        public void Stop()
        {
            _meterListener?.Dispose();
            _meterListener = null;

            _meterProvider?.Dispose();
            _meterProvider = null;

            _sdkLogger?.Dispose();
            _sdkLogger = null;
        }

        public override void Dispose()
        {
            Stop();

            base.Dispose();
        }

        /// <summary>
        /// Creates a MeterListener instance using the MeterListner type from the customer's application, and subscribes to the necessary hooks
        /// that allows us to bridge the Meters, Instruments, and Measurements to make them visible to our ILRepacked code.
        /// </summary>
        private void TryCreateMeterListener()
        {
            // TODO: If the logic for this method is moved to another class, and with that class we can pass in either a separate AppDomain or assembly load context or just a separate assembly, we may be able to unit test more of the bridging logic.
            var assembly = AppDomain.CurrentDomain.GetAssemblies().FirstOrDefault(a => a.GetName().Name == "System.Diagnostics.DiagnosticSource");
            if (assembly == null)
            {
                Log.Warn("System.Diagnostics.DiagnosticSource assembly not found. Cannot create MeterListener.");
                return;
            }

            var meterListenerType = assembly.GetType("System.Diagnostics.Metrics.MeterListener", throwOnError: false);
            var ilRepackedMeterListenerType = typeof(MeterListener);

            if (meterListenerType == ilRepackedMeterListenerType)
            {
                // This scenario should not happen in a customer application, but is possible in all of our
                // unit tests, because our unit tests do not run against the ilrepacked version of the agent.
                Log.Warn("MeterListener type in application matches ILRepacked MeterListener type.");
                return;
            }

            var instrumentType = assembly.GetType("System.Diagnostics.Metrics.Instrument", throwOnError: false);

            if (meterListenerType == null || instrumentType == null)
            {
                Log.Warn("Required types not found in DiagnosticSource assembly. MeterListener: {0}, Instrument: {1}",
                    meterListenerType != null, instrumentType != null);
                return;
            }

            try
            {
                _meterListener = Activator.CreateInstance(meterListenerType);

                SubscribeToInstrumentPublishedEvent(meterListenerType, instrumentType);

                SubscribeToMeasurementUpdates<byte>(meterListenerType, instrumentType);
                SubscribeToMeasurementUpdates<short>(meterListenerType, instrumentType);
                SubscribeToMeasurementUpdates<int>(meterListenerType, instrumentType);
                SubscribeToMeasurementUpdates<long>(meterListenerType, instrumentType);
                SubscribeToMeasurementUpdates<float>(meterListenerType, instrumentType);
                SubscribeToMeasurementUpdates<double>(meterListenerType, instrumentType);
                SubscribeToMeasurementUpdates<decimal>(meterListenerType, instrumentType);

                SubscribeToMeasurementCompletedEvent(meterListenerType, instrumentType);

                Log.Debug("Successfully created and configured MeterListener for OpenTelemetry bridging");
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Failed to configure MeterListener subscriptions");
                _meterListener?.Dispose();
                _meterListener = null;
                throw;
            }
        }

        /// <summary>
        /// Dynamically contructs a lambda that will be used to subscribe to the InstrumentPublished event on the MeterListener.
        ///
        /// void InstrumentPublished(Instrument instrument, MeterListener listener)
        /// {
        ///    if (MeterListenerBridge.ShouldEnableInstrumentsInMeterWithFilters(instrument.Meter.Name))
        ///    {
        ///      listener.EnableMeasurementEvents(instrument, MeterListenerBridge.GetStateForInstrument(instrument));
        ///    }
        /// }
        /// </summary>
        /// <param name="meterListenerType"> The Type representing the MeterListener class in the customer's application</param>
        /// <param name="instrumentType">The Type representing the Instrument class in the customer's application</param>
        private void SubscribeToInstrumentPublishedEvent(Type meterListenerType, Type instrumentType)
        {
            var instrumentPublishProperty = meterListenerType.GetProperty("InstrumentPublished");

            var instrumentParameter = Expression.Parameter(instrumentType, "instrument");
            var listenerParameter = Expression.Parameter(meterListenerType, "listener");

            var meterNameProperty = Expression.Property(Expression.Property(instrumentParameter, "Meter"), "Name");

            var shouldEnableMethod = typeof(MeterListenerBridge).GetMethod(nameof(ShouldEnableInstrumentsInMeterWithFilters), BindingFlags.NonPublic | BindingFlags.Instance);
            var shouldEnableCall = Expression.Call(Expression.Constant(this), shouldEnableMethod, meterNameProperty);

            var getInstrumentStateMethod = typeof(MeterListenerBridge).GetMethod(nameof(GetStateForInstrument), BindingFlags.NonPublic | BindingFlags.Static);
            var getInstrumentStateCall = Expression.Call(null, getInstrumentStateMethod, instrumentParameter);

            var enableMeasurementEventsMethod = Expression.Call(listenerParameter, "EnableMeasurementEvents", null, instrumentParameter, getInstrumentStateCall);

            var lambdaBody = Expression.IfThen(shouldEnableCall, enableMeasurementEventsMethod);

            var lambda = Expression.Lambda(instrumentPublishProperty.PropertyType, lambdaBody, instrumentParameter, listenerParameter);

            instrumentPublishProperty.SetValue(_meterListener, lambda.Compile());
        }

        /// <summary>
        /// Dynamically contructs a lambda that will be used to subscribe to the MeasurementEventCallback event and then registers the lambda
        /// as the callback on the MeterListener.
        ///
        /// void MeasurementEventCallback(Instrument instrument, T measurement, ReadOnlySpan<KeyValuePair<string, object>> tags, object state)
        /// {
        ///    MeterListenerBridge.OnMeasurementRecorded(instrument, measurement, tags, state);
        /// }
        ///
        /// _meterListener.SetMeasurementEventCallback(MeasurementEventCallback);
        /// </summary>
        /// <typeparam name="T">The Measurement Type that represents the numeric type of the value stored in a Measurement</typeparam>
        /// <param name="meterListenerType"> The Type representing the MeterListener class in the customer's application</param>
        /// <param name="instrumentType">The Type representing the Instrument class in the customer's application</param>
        private void SubscribeToMeasurementUpdates<T>(Type meterListenerType, Type instrumentType)
        {
            var setMeasurementEventCallbackMethodInfo = meterListenerType.GetMethod("SetMeasurementEventCallback").MakeGenericMethod(typeof(T));
            var callbackDelegateType = setMeasurementEventCallbackMethodInfo.GetParameters()[0].ParameterType;

            var instrumentParameter = Expression.Parameter(instrumentType, "measurement");
            var measurementParameter = Expression.Parameter(typeof(T), "measurement");
            var tagsParameter = Expression.Parameter(typeof(ReadOnlySpan<KeyValuePair<string, object>>), "tags");
            var stateParameter = Expression.Parameter(typeof(object), "state");

            var methodCall = Expression.Call(
                typeof(MeterListenerBridge),
                nameof(OnMeasurementRecorded),
                [typeof(T)],
                instrumentParameter,
                measurementParameter,
                tagsParameter,
                stateParameter);
            var measurementRecordedLambda = Expression.Lambda(callbackDelegateType, methodCall, instrumentParameter, measurementParameter, tagsParameter, stateParameter);

            setMeasurementEventCallbackMethodInfo.Invoke(_meterListener, new object[] { measurementRecordedLambda.Compile() });
        }

        /// <summary>
        /// Dynamically contructs a lambda that will be used to subscribe to the MeasurementsCompleted event and then registers the lambda
        /// with the MeterListener.
        ///
        /// void MeasurementsCompleted(Instrument instrument, object state)
        /// {
        ///    MeterListenerBridge.DisableBridgedInstrument(state);
        /// }
        ///
        /// _meterListener.MeasurementsCompleted = MeasurementsCompleted;
        /// </summary>
        /// <param name="meterListenerType"> The Type representing the MeterListener class in the customer's application</param>
        /// <param name="instrumentType">The Type representing the Instrument class in the customer's application</param>
        private void SubscribeToMeasurementCompletedEvent(Type meterListenerType, Type instrumentType)
        {
            var measurementsCompletedProperty = meterListenerType.GetProperty("MeasurementsCompleted");

            var instrumentParameter = Expression.Parameter(instrumentType, "instrument");
            var stateParameter = Expression.Parameter(typeof(object), "state");

            var disableBridgedInstrumentMethod = typeof(MeterListenerBridge).GetMethod(nameof(DisableBridgedInstrument), BindingFlags.NonPublic | BindingFlags.Static);
            var disableBridgedInstrumentCall = Expression.Call(null, disableBridgedInstrumentMethod, stateParameter);

            var measurmentsCompletedLambda = Expression.Lambda(measurementsCompletedProperty.PropertyType, disableBridgedInstrumentCall, instrumentParameter, stateParameter);

            measurementsCompletedProperty.SetValue(_meterListener, measurmentsCompletedLambda.Compile());
        }

        private static void DisableBridgedInstrument(object state)
        {
            if (state == null)
            {
                return;
            }

            var bridgedInstrument = state as Instrument;
            if (bridgedInstrument == null)
            {
                return;
            }

            // The MeasurementsCompleted event is triggered when an instrument is no longer being subscribed to by a MeterListener
            // or the Meter holding the instrumented is Disposed. In our use case, we subscribe to all instruments in a meter and
            // do not disable individual individual instruments, so the only way this event will be triggered is if the corresponding
            // meter is no longer being used by the application or if our MeterListener is being Disposed. In either case we can
            // just Dispose of the bridged Meter.

            if (_bridgedMeters.TryRemove(bridgedInstrument.Meter.Name, out var bridgedMeter))
            {
                var meterName = bridgedMeter.Name;
                bridgedMeter.Dispose();
                Log.Debug($"Disposed bridged meter: {meterName}");
            }
        }


        private static bool ShouldEnableInstrumentsInMeter(string meterName)
        {
            // TODO: If the agent ever targets .net 9 the .net 9 build of the agent will not need to bridge the runtime metrics meter that is
            // built into the diagnostics source library. This check will need to be updated to not bridge the runtime metrics meter.

            // Skip internal diagnostic meters to avoid potential recursion
            if (string.IsNullOrEmpty(meterName))
            {
                return false;
            }

            // Filter out internal infrastructure meters that could cause recursion
            if (meterName.StartsWith("NewRelic", StringComparison.OrdinalIgnoreCase) ||
                meterName.StartsWith("OpenTelemetry", StringComparison.OrdinalIgnoreCase) ||
                meterName.StartsWith("System.Diagnostics" + ".Metrics", StringComparison.OrdinalIgnoreCase))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Determines whether instruments in the specified meter should be enabled based on the 
        /// OpenTelemetry metrics configuration filters (include/exclude lists).
        /// Follows the precedence logic:
        /// 1. Built-in exclude list
        /// 2. Customer configured include list  
        /// 3. Customer configured exclude list
        /// </summary>
        /// <param name="meterName">The name of the meter to check</param>
        /// <returns>True if the meter should be enabled; false otherwise</returns>
        private bool ShouldEnableInstrumentsInMeterWithFilters(string meterName)
        {
            // First apply the built-in filtering logic
            if (!ShouldEnableInstrumentsInMeter(meterName))
            {
                return false;
            }

            // Check if OpenTelemetry is enabled overall
            if (!_configuration.OpenTelemetryEnabled)
            {
                return false;
            }

            // Check if OpenTelemetry metrics are enabled
            if (!_configuration.OpenTelemetryMetricsEnabled)
            {
                return false;
            }

            var includeFilters = _configuration.OpenTelemetryMetricsIncludeFilters?.ToList() ?? new List<string>();
            var excludeFilters = _configuration.OpenTelemetryMetricsExcludeFilters?.ToList() ?? new List<string>();

            // If include filters are specified, the meter must be in the include list
            if (includeFilters.Any() && !includeFilters.Contains(meterName))
            {
                Log.Finest($"Meter '{meterName}' not in include list. Not enabling instruments.");
                return false;
            }

            // If the meter is in the exclude list, don't enable it
            if (excludeFilters.Contains(meterName))
            {
                Log.Finest($"Meter '{meterName}' is in exclude list. Not enabling instruments.");
                return false;
            }

            Log.Finest($"Meter '{meterName}' passed all filters. Enabling instruments.");
            return true;
        }

        /// <summary>
        /// Creates the bridged Meters and Instruments, and returns the state object that can be used by the other callbacks triggered by
        /// the MeterListener.
        /// </summary>
        /// <param name="instrument">The original Instrument instance</param>
        /// <returns>The state object the MeterListener should use for each Instrument callback. This value is either null or the bridged
        /// Instrument' instance corresponding to the original instrument.</returns>
        private static object GetStateForInstrument(object instrument)
        {
            dynamic dynamicInstrument = instrument;
            var instrumentType = instrument.GetType();
            var genericType = instrumentType.GetGenericArguments().FirstOrDefault();

            if (genericType == null)
            {
                return null;
            }

            Meter meter = _bridgedMeters.GetOrAdd(dynamicInstrument.Meter.Name, (Func<string, Meter>)CreateBridgedMeterFromInstrument);

            if (dynamicInstrument.IsObservable)
            {
                var cacheData = _createObservableInstrumentCache.GetOrAdd(instrumentType, GetObservableInstrumentCacheData);
                if (cacheData == null)
                {
                    return null;
                }

                var createCallbackAndObservableInstrument = cacheData.CreateCallbackAndObservableInstrumentDelegate;
                return createCallbackAndObservableInstrument(instrument, meter, cacheData);
            }

            var createInstrumentDelegate = (Func<Meter, string, string, string, object>)_createInstrumentDelegates.GetOrAdd(instrumentType, CreateBridgedInstrumentDelegate);

            if (createInstrumentDelegate == null)
            {
                return null;
            }

            // TODO: Tags are not avaiilable on older instruments, need a way to dynamically get them for newer versions
            return createInstrumentDelegate.Invoke(meter, dynamicInstrument.Name, dynamicInstrument.Unit, dynamicInstrument.Description);

            Meter CreateBridgedMeterFromInstrument(string _)
            {
                return CreateBridgedMeter(dynamicInstrument.Meter);
            }
        }

        private static ObservableInstrumentCacheData GetObservableInstrumentCacheData(Type instrumentType)
        {
            var genericType = instrumentType.GetGenericArguments().FirstOrDefault();
            if (genericType == null)
            {
                return null;
            }

            var cacheData = new ObservableInstrumentCacheData();
            cacheData.CreateObservableInstrumentDelegate = CreateBridgedObservableInstrumentDelegate(instrumentType);
            cacheData.CreateCallbackAndObservableInstrumentDelegate = CreateCallbackAndBridgedObservableInstrumentAction(instrumentType);
            cacheData.ObserveMethodDelegate = CreateObserveMethodInvoker(instrumentType);

            return cacheData;
        }

        /// <summary>
        /// Creates a delegate that can be used to invoke the internal Observe() method on an Observable Instrument instance.
        ///
        /// IEnumerable InvokeObserveMethod(object instrument)
        /// {
        ///    var typedInstrument = (InstrumentType)instrument;
        ///    return (IEnumerable)typedInstrument.Observe();
        /// }
        /// </summary>
        /// <param name="instrumentType">The Type representing the Instrument class in the customer's application</param>
        /// <returns></returns>
        public static Func<object, IEnumerable> CreateObserveMethodInvoker(Type instrumentType)
        {
            var observeMethod = instrumentType.GetMethod("Observe", BindingFlags.NonPublic | BindingFlags.Instance, null, Type.EmptyTypes, null);
            var instrumentParameter = Expression.Parameter(typeof(object), "instrument");
            var typedInstrument = Expression.Convert(instrumentParameter, instrumentType);
            var observeMethodCall = Expression.Call(typedInstrument, observeMethod);
            var convertedResult = Expression.Convert(observeMethodCall, typeof(IEnumerable));
            var lambda = Expression.Lambda<Func<object, IEnumerable>>(convertedResult, instrumentParameter);

            return lambda.Compile();
        }

        private static Func<object, Meter, ObservableInstrumentCacheData, Instrument> CreateCallbackAndBridgedObservableInstrumentAction(Type instrumentType)
        {
            var genericType = instrumentType.GetGenericArguments().FirstOrDefault();
            var methodInfo = typeof(MeterListenerBridge).GetMethod(nameof(CreateCallbackAndBridgedObservableInstrument), BindingFlags.NonPublic | BindingFlags.Static).MakeGenericMethod(genericType);
            return (Func<object, Meter, ObservableInstrumentCacheData, Instrument>)methodInfo.CreateDelegate(typeof(Func<object, Meter, ObservableInstrumentCacheData, Instrument>));
        }

        private static Instrument CreateCallbackAndBridgedObservableInstrument<T>(object instrument, Meter meter, ObservableInstrumentCacheData cacheData) where T : struct
        {
            var createObservableInstrument = (CreateObservableInstrumentDelegate<T>)cacheData.CreateObservableInstrumentDelegate;
            if (createObservableInstrument == null)
            {
                return null;
            }

            dynamic dynamicInstrument = instrument;

            // Need to create a function that can call the Observe() method on the instrument (the protected parameterless method)
            // and transform the IEnumerable<Measurement<T>> into the bridged IEnumerable<Measurement<T>> that the ilrepacked code expects

            var observeMethod = cacheData.ObserveMethodDelegate;
            return createObservableInstrument(meter, (string)dynamicInstrument.Name, ForwardObservedMeasurements, (string)dynamicInstrument.Unit, (string)dynamicInstrument.Description);

            IEnumerable<Measurement<T>> ForwardObservedMeasurements()
            {
                return BridgeMeasurements<T>(observeMethod(instrument));
            }
        }

        private static IEnumerable<Measurement<T>> BridgeMeasurements<T>(IEnumerable originalMeasurements) where T : struct
        {
            var bridgedMeasurements = new List<Measurement<T>>();
            Func<object, Measurement<T>> createBridgedMeasurement = null;
            foreach (var measurement in originalMeasurements)
            {
                // Initializing the delegate to create the bridged measurment within the loop because the type of the original measurements
                // is not IEnumerable<Measurement<T>> but is the concrete collection instead (which may change in the future).
                if (createBridgedMeasurement == null)
                {
                    createBridgedMeasurement = (Func<object, Measurement<T>>)_bridgeMeasurementDelegates.GetOrAdd(measurement.GetType(), GetMethodToBridgeMeasurement<T>);
                }
                bridgedMeasurements.Add(createBridgedMeasurement(measurement));
            }

            return bridgedMeasurements;
        }

        /// <summary>
        /// Dynamically creates a delegate that can be used to bridge the Measurement instances from the customer's application to the ILRepacked
        /// Measurement' instances. The Tags on a Measurement are a special type that cannot be stored or referenced using object variables
        /// or the dynamic type system. We need to dynamically create a strongly typed method that can access these values so that they can be
        /// bridged.
        ///
        /// Measurement<T> BridgeMeasurement<T>(object originalMeasurement)
        /// {
        ///    var typedMeasurement = (OriginalMeasurementType)originalMeasurement;
        ///    var bridgedMeasurement = new Measurement<T>(typedMeasurement.Value, typedMeasurement.Tags);
        /// }
        /// </summary>
        /// <typeparam name="T">The Measurement Type that represents the numeric type of the value stored in a Measurement</typeparam>
        /// <param name="originalMeasurementType">The Type that represents the original Measurement type from the customer's application</param>
        /// <returns>A delegate that takes the original Measurement instance and returns a bridged Measurement' instance</returns>
        private static Func<object, Measurement<T>> GetMethodToBridgeMeasurement<T>(Type originalMeasurementType) where T : struct
        {
            var measurementConstructor = typeof(Measurement<T>).GetConstructor([typeof(T), typeof(ReadOnlySpan<KeyValuePair<string, object>>)]);
            if (measurementConstructor == null)
            {
                return null;
            }

            var originalMeasurementParameter = Expression.Parameter(typeof(object), "originalMeasurement");
            var typedOriginalMeasurement = Expression.Convert(originalMeasurementParameter, originalMeasurementType);

            var valuePropertyAccess = Expression.Property(typedOriginalMeasurement, originalMeasurementType, "Value");
            var tagsPropertyAccess = Expression.Property(typedOriginalMeasurement, originalMeasurementType, "Tags");

            var newMeasurement = Expression.New(measurementConstructor, valuePropertyAccess, tagsPropertyAccess);
            var lambda = Expression.Lambda<Func<object, Measurement<T>>>(newMeasurement, originalMeasurementParameter);

            return lambda.Compile();
        }

        private static Func<Meter, string, string, string, object> CreateBridgedInstrumentDelegate(Type originalInstrumentType)
        {
            var genericType = originalInstrumentType.GetGenericArguments().FirstOrDefault();
            if (genericType == null)
            {
                return null;
            }

            var createInstrumentMethodName = originalInstrumentType.Name switch
            {
                "Counter`1" => "CreateCounter",
                "Histogram`1" => "CreateHistogram",
                "UpDownCounter`1" => "CreateUpDownCounter",
                "Gauge`1" => "CreateGauge",
                _ => null
            };

            if (createInstrumentMethodName == null)
            {
                return null;
            }

            // TODO: If we upgrade .NET or see test failures related to this reflection, revisit this logic.
            // Reflection logic for Meter.Create* methods:
            // 1. Try to match the latest public OTel signature (4 parameters: name, unit, description, tags)
            // 2. Fallback to 3-parameter version (name, unit, description) for backward compatibility
            // 3. Always match by parameter types, not just count
            // 4. If neither found, return null (fail fast in tests)
            // See: https://github.com/dotnet/runtime/blob/main/src/libraries/System.Diagnostics.DiagnosticSource/src/System/Diagnostics/Metrics/Meter.cs
            MethodInfo methodInfo = null;
            try
            {
                // Try 4-parameter overload (name, unit, description, tags)
                methodInfo = typeof(Meter).GetMethods()
                    .FirstOrDefault(m =>
                        m.Name == createInstrumentMethodName &&
                        m.IsGenericMethod &&
                        m.GetParameters().Select(p => p.ParameterType)
                            .SequenceEqual(new[] { typeof(string), typeof(string), typeof(string), typeof(IEnumerable<KeyValuePair<string, object>>) })
                    );
                if (methodInfo != null)
                {
                    methodInfo = methodInfo.MakeGenericMethod(genericType);
                    // Wrap in a delegate that ignores the 4th argument (tags) for now (pass null)
                    return (meter, name, unit, description) => methodInfo.Invoke(meter, new object[] { name, unit, description, null });
                }

                // Fallback: Try 3-parameter overload (name, unit, description)
                methodInfo = typeof(Meter).GetMethods()
                    .FirstOrDefault(m =>
                        m.Name == createInstrumentMethodName &&
                        m.IsGenericMethod &&
                        m.GetParameters().Select(p => p.ParameterType)
                            .SequenceEqual(new[] { typeof(string), typeof(string), typeof(string) })
                    );
                if (methodInfo != null)
                {
                    methodInfo = methodInfo.MakeGenericMethod(genericType);
                    return (Func<Meter, string, string, string, object>)methodInfo.CreateDelegate(typeof(Func<Meter, string, string, string, object>));
                }
            }
            catch (Exception ex)
            {
                Log.Debug(ex, $"Reflection failed for {createInstrumentMethodName}<{genericType}>");
            }

            // If method not found, return null
            return null;
        }

        private static Delegate CreateBridgedObservableInstrumentDelegate(Type originalInstrumentType)
        {
            var genericType = originalInstrumentType.GetGenericArguments().FirstOrDefault();
            if (genericType == null)
            {
                return null;
            }

            var createInstrumentMethodName = originalInstrumentType.Name switch
            {
                "ObservableCounter`1" => nameof(CreateBridgedObservableCounter),
                "ObservableGauge`1" => nameof(CreateBridgedObservableGauge),
                "ObservableUpDownCounter`1" => nameof(CreateBridgedObservableUpDownCounter),
                _ => null
            };

            if (createInstrumentMethodName == null)
            {
                return null;
            }

            var delegateType = typeof(CreateObservableInstrumentDelegate<>).MakeGenericType(genericType);
            var methodInfo = typeof(MeterListenerBridge).GetMethod(createInstrumentMethodName, BindingFlags.NonPublic | BindingFlags.Static).MakeGenericMethod(genericType);
            var createDelegate = methodInfo.CreateDelegate(delegateType);

            return createDelegate;
        }

        private delegate Instrument CreateObservableInstrumentDelegate<T>(Meter meter, string name, Func<IEnumerable<Measurement<T>>> callback, string unit, string description) where T : struct;

        private static Instrument CreateBridgedObservableCounter<T>(Meter meter, string name, Func<IEnumerable<Measurement<T>>> callback, string unit, string description) where T : struct
        {
            return meter.CreateObservableCounter(name, callback, unit, description);
        }

        private static Instrument CreateBridgedObservableGauge<T>(Meter meter, string name, Func<IEnumerable<Measurement<T>>> callback, string unit, string description) where T : struct
        {
            return meter.CreateObservableGauge(name, callback, unit, description);
        }

        private static Instrument CreateBridgedObservableUpDownCounter<T>(Meter meter, string name, Func<IEnumerable<Measurement<T>>> callback, string unit, string description) where T : struct
        {
            return meter.CreateObservableUpDownCounter(name, callback, unit, description);
        }

        private static Meter CreateBridgedMeter(object meter)
        {
            dynamic dynamicMeter = meter;

            // TODO: Tags and Scope are not available on older meters, need a way to dynamically get them for newer versions
            return new Meter(dynamicMeter.Name, dynamicMeter.Version);
        }

        private static void OnMeasurementRecorded<T>(object instrument, T measurement, ReadOnlySpan<KeyValuePair<string, object>> tags, object state)
            where T : struct
        {
            try
            {
                if (state == null)
                {
                    return;
                }

                switch (state)
                {
                    case Counter<T> counter:
                        counter.Add(measurement, tags);
                        Log.Finest($"Bridged measurement {measurement} to counter {counter.Meter.Name}.{counter.Name}");
                        break;
                    case Histogram<T> histogram:
                        histogram.Record(measurement, tags);
                        Log.Finest($"Bridged measurement {measurement} to histogram {histogram.Meter.Name}.{histogram.Name}");
                        break;
                    case UpDownCounter<T> upDownCounter:
                        upDownCounter.Add(measurement, tags);
                        Log.Finest($"Bridged measurement {measurement} to upDownCounter {upDownCounter.Meter.Name}.{upDownCounter.Name}");
                        break;
                        // TODO: Add support for Gauge<T> and remove the gauge logic from the default case.
                    default:
                        // Runtime support for Gauge<T> (for .NET 8+) even if compiled against older frameworks
                        var stateType = state.GetType();
                        if (stateType.Name.StartsWith("Gauge`1"))
                        {
                            var recordMethod = stateType.GetMethod("Record", new[] { typeof(T), typeof(ReadOnlySpan<KeyValuePair<string, object>>) })
                                                ?? stateType.GetMethod("Record", new[] { typeof(T), typeof(TagList) });
                            if (recordMethod != null)
                            {
                                // ReadOnlySpan<T> cannot be boxed, so convert to array for reflection
                                recordMethod.Invoke(state, new object[] { measurement, tags.ToArray() });
                                var meterProp = stateType.GetProperty("Meter");
                                var nameProp = stateType.GetProperty("Name");
                                var meterName = meterProp?.GetValue(state)?.GetType().GetProperty("Name")?.GetValue(meterProp.GetValue(state));
                                var gaugeName = nameProp?.GetValue(state);
                                Log.Finest($"Bridged measurement {measurement} to gauge {meterName}.{gaugeName}");
                                break;
                            }
                        }
                        Log.Debug($"Unsupported instrument type for measurement bridging: {stateType.Name}");
                        break;
                }
            }
            catch (Exception ex)
            {
                Log.Warn(ex, "Failed to record measurement for instrument type: {0}", state?.GetType()?.Name ?? "unknown");
            }
        }

        public class ObservableInstrumentCacheData
        {
            public Delegate CreateObservableInstrumentDelegate { get; set; }
            public Func<object, Meter, ObservableInstrumentCacheData, Instrument> CreateCallbackAndObservableInstrumentDelegate { get; set; }
            public Func<object, IEnumerable> ObserveMethodDelegate { get; set; }
        }
    }
}
