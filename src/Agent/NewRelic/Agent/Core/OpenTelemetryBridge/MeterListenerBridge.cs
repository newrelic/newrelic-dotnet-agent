// Copyright 2020 New Relic, Inc. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Linq;
using System.Linq.Expressions;
using System.Net.Http;
using System.Reflection;
#if NETFRAMEWORK
using System.Reflection.Emit;
#endif
using NewRelic.Agent.Core.DataTransport;
using NewRelic.Agent.Core.Events;
using NewRelic.Agent.Core.Logging;
using NewRelic.Agent.Core.Metrics;
using NewRelic.Agent.Core.Utilities;
using NewRelic.Agent.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Exporter;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;

namespace NewRelic.Agent.Core.OpenTelemetryBridge
{
    // This class is used as a bridge between the DiagnosticSource library included with an application, and the version of the DiagnosticSource library
    // and OpenTelemetrySDK included with the New Relic agent. This allows the customer's application to use a different version of the DiagnosticSource
    // library than the agent, and still have the agent collect metrics from the application's instruments. This approach allows us to handle scenarios
    // where it is not possible for the agent to force a newer version of the DiagnosticSource library to load, which can happen when an older version
    // of the DiagnosticSource library is included in the application's working directory (or build output).
    //
    // This solution works by including an ILRepacked version of the DiagnosticSource library in the agent. The agent can directly reference the code in
    // the ILRepacked library. In this documentation we will refer to the ILRepacked types as Meter', Instrument', Measurement', etc. The "'" character
    // is used to indicated that we are talking about an ILRepacked type. The types available in the customer's application will not have the "'" suffix.
    //
    // To collect metric data from the Metrics API, you need to create a MeterListener. MeterListeners operate in a pub-sub model where MeterListeners
    // subscribe to Instruments published by Meters. When an Instrument is published, the MeterListener will subscribe to the Instrument and listen for
    // measurements. When measurements are recorded on the Instrument, the MeterListener will receive the measurements and process them as necessary.
    // If there are no listeners for an Instrument the measurements for that instrument will be dropped and not stored anywhere. Because of the way
    // this pub-sub model is implemented, a MeterListener' (an ILRepacked MeterListener) instance cannot subscribe to data generated by a Meter (from
    // the customer's application) instance. The pub-sub model relies on static fields linking MeterListeners to Meters and so the ILRepacked MeterListeners
    // can only see ILRepacked Meters. To workaround this, we need to build a MeterListener dynamically at runtime using the MeterListener type from the
    // customer's application. This will allows us to forward the data from the types in the customer's application to the ILRepacked types in the agent.
    //
    // We use a combination of reflection and expression trees to build the MeterListener at runtime. The solution works by recreating all Meters,
    // Instruments, and Measurements in the customer's application using the ILRepacked types. The MeterListener class provides 3 main hooks that we
    // leverage to bridge the data between the 2 library versions.
    //
    // 1. InstrumentPublished: This event is triggered when an Instrument is published by a Meter. We subscribe to this event and create a bridged
    //     version of the Meter and Instrument and copying all of the available data over to Meter' and Instrument'.
    // 2. MeasurementEventCallback: This event is triggered when a measurement is recorded on an Instrument. We subscribe to this event and forward
    //     the measurement as a bridged Measurement' to the bridged Instrument'. We use the state parameter to store the bridged Instrument' instance
    //     so that we do not need to maintain our own dictionary to manage the mapping.
    // 3. MeasurementsCompleted: This event is triggered when an Instrument is no longer being subscribed to by a MeterListener or the Meter holding
    //     the instrumented is Disposed. In our use case, we subscribe to all instruments in a meter and do not disable individual instruments, so
    //     the only way this event will be triggered is if the corresponding meter is no longer being used by the application or if our MeterListener
    //     is being Disposed. In either case we can just Dispose of the bridged Meter', which will clean up all of our bridged Instrument' instances.
    //
    // Observable Instruments require special handling, because the values for Observable Instruments are not recorded directly on the Instrument, because
    // they rely on a Pull-based model. This pull typically happens when someone wants to export the metric data somewhere. In order to handle Observable
    // Instruments, we create a callback on the bridged observable Instrument' that will call the internal Observe() method on the original Instrument
    // to retrieve an IEnumerable<Measurement<T>> collection, that we can use to create a bridged IEnumerable<Measurement<T>'> collection returned by
    // our callback. As a result, we do not rely on our MeterListener triggering the collection of all observable Instruments, and then forwarding the
    // data using the MeasurementEventCallback. We instead rely on the OpenTelemetry Exporter configured using the OpenTelemetry SDK to trigger the
    // collection of bridged observable Instruments', which will run our registered callbacks that bridge the data from the original observable
    // Instruments.
    public class MeterListenerBridge : ConfigurationBasedService
    {
        private dynamic _meterListener;
        private static Meter NewRelicBridgeMeter = new Meter("NewRelicOTelBridgeMeter");
        private static ConcurrentDictionary<string, Meter> _bridgedMeters = new ConcurrentDictionary<string, Meter>();
        private static ConcurrentDictionary<Type, object> _createInstrumentDelegates = new ConcurrentDictionary<Type, object>();
        private static ConcurrentDictionary<Type, object> _bridgeMeasurementDelegates = new ConcurrentDictionary<Type, object>();
        private static ConcurrentDictionary<Type, ObservableInstrumentCacheData> _createObservableInstrumentCache = new ConcurrentDictionary<Type, ObservableInstrumentCacheData>();

        private OpenTelemetrySDKLogger _sdkLogger;
        private MeterProvider _meterProvider;
        private readonly object _meterProviderLock = new object();
        private IConnectionInfo _connectionInfo;
        private string _currentEntityGuid;

        // Service dependencies
        private readonly IOtelBridgeSupportabilityMetricCounters _supportabilityMetricCounters;

        // Configuration constants for OTLP export
        private const int DefaultOtlpTimeoutSeconds = 10;
        private const int DefaultOtlpExportIntervalSeconds = 5;

        private static MeterListenerBridge _bridgeInstance;

        public MeterListenerBridge(IOtelBridgeSupportabilityMetricCounters supportabilityMetricCounters)
        {
            _supportabilityMetricCounters = supportabilityMetricCounters;
            _subscriptions.Add<AgentConnectedEvent>(OnAgentConnected);
            _subscriptions.Add<ServerConfigurationUpdatedEvent>(OnServerConfigurationUpdated);
            _subscriptions.Add<PreCleanShutdownEvent>(OnPreCleanShutdown);
        }

        private void OnAgentConnected(AgentConnectedEvent agentConnectedEvent)
        {
            Stop();
            _connectionInfo = agentConnectedEvent.ConnectInfo;

            // Initialize EntityGuid tracking from current configuration 
            // (ServerConfiguration will be processed separately via ServerConfigurationUpdatedEvent)
            _currentEntityGuid = _configuration.EntityGuid;

            Start();
        }

        private void OnPreCleanShutdown(PreCleanShutdownEvent preCleanShutdownEvent)
        {
            Stop();
        }

        private void OnServerConfigurationUpdated(ServerConfigurationUpdatedEvent serverConfigurationUpdatedEvent)
        {
            // Check if EntityGuid has changed and recreate MeterProvider if needed
            var newEntityGuid = serverConfigurationUpdatedEvent.Configuration.EntityGuid;

            if (!string.IsNullOrEmpty(_currentEntityGuid) &&
                !string.IsNullOrEmpty(newEntityGuid) &&
                _currentEntityGuid != newEntityGuid)
            {
                Log.Debug($"EntityGuid changed from '{_currentEntityGuid}' to '{newEntityGuid}'. Recreating OTel MeterProvider.");
                _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.EntityGuidChanged);

                // Update the tracked EntityGuid
                _currentEntityGuid = newEntityGuid;

                // Recreate the MeterProvider with the new EntityGuid if we have connection info
                if (_connectionInfo != null && _configuration.OpenTelemetryMetricsEnabled)
                {
                    RecreateMetricsProvider();
                }
            }
            else if (string.IsNullOrEmpty(_currentEntityGuid) && !string.IsNullOrEmpty(newEntityGuid))
            {
                // First time setting EntityGuid
                _currentEntityGuid = newEntityGuid;
                Log.Debug($"EntityGuid set to '{_currentEntityGuid}' for the first time.");
            }
        }

        protected override void OnConfigurationUpdated(ConfigurationUpdateSource configurationUpdateSource)
        {
            // Nothing to do here, but this abstract method must be implemented.
            // The real work will start once the agent is connected.
        }

        /// <summary>
        /// Creates and configures a new OpenTelemetry MeterProvider with the current configuration.
        /// </summary>
        /// <returns>A configured MeterProvider instance, or null if connection info is not available</returns>
        private MeterProvider CreateMeterProvider()
        {
            if (_connectionInfo == null)
            {
                Log.Debug("Cannot create MeterProvider: connection info not available.");
                return null;
            }

            var uriBuilder = new UriBuilder(_connectionInfo.HttpProtocol, _connectionInfo.Host, _connectionInfo.Port, "/v1/metrics");

            var providerBuilder = Sdk.CreateMeterProviderBuilder()
                .ConfigureResource(r => r
                    .AddService(_configuration.ApplicationNames.First())
                    .AddTelemetrySdk()
                    .AddAttributes([new KeyValuePair<string, object>("entity.guid", _currentEntityGuid ?? _configuration.EntityGuid)]))
                .AddMeter("*")
                .AddOtlpExporter((exporterOptions, metricReaderOptions) =>
                {
                    exporterOptions.Endpoint = uriBuilder.Uri;
                    exporterOptions.Protocol = OtlpExportProtocol.HttpProtobuf;
                    exporterOptions.Headers = $"api-key={_configuration.AgentLicenseKey}";

                    // Configure HttpClient factory with proxy and retry logic
                    exporterOptions.HttpClientFactory = CreateHttpClientWithProxyAndRetry;

                    // TODO: Determine if we still need this code block
#if NETSTANDARD2_0_OR_GREATER
                    // Additional .NET Standard specific configurations can go here if needed
#endif
                    // Configure metric collection and export settings
                    metricReaderOptions.PeriodicExportingMetricReaderOptions.ExportIntervalMilliseconds = DefaultOtlpExportIntervalSeconds * 1000;
                    metricReaderOptions.TemporalityPreference = MetricReaderTemporalityPreference.Delta;
                });

            return providerBuilder.Build();
        }

        /// <summary>
        /// Starts the meter listener bridge to begin collecting and forwarding metrics.
        /// Initializes the OpenTelemetry SDK, configures OTLP export, and sets up the MeterListener.
        /// </summary>
        public void Start()
        {
            if (!_configuration.OpenTelemetryMetricsEnabled)
            {
                Log.Debug("OpenTelemetry Meter Bridge is disabled via configuration.");
                return;
            }

            if (_connectionInfo == null)
            {
                Log.Debug("OpenTelemetry Meter Bridge cannot start: connection info not available.");
                return;
            }

            if (_sdkLogger == null)
            {
                _sdkLogger = new OpenTelemetrySDKLogger();
            }
            // The first if (_meterProvider == null) check avoids acquiring the lock when the provider is already initialized
            // This prevents unnecessary lock contention on every Start() call after initialization
            if (_meterProvider == null)
            {
                lock (_meterProviderLock)
                {
                    if (_meterProvider == null)
                    {
                        _meterProvider = CreateMeterProvider();
                    }
                }
            }

            if (_meterListener == null)
            {
                try
                {
                    // Capture bridge instance for dynamic callbacks
                    _bridgeInstance = this;
                    TryCreateMeterListener();
                }
                catch (Exception ex)
                {
                    Log.Warn(ex, "Failed to create MeterListener");
                }
                _meterListener?.Start();
            }
        }

        /// <summary>
        /// Recreates the OpenTelemetry MeterProvider when the EntityGuid changes.
        /// This ensures that metrics are reported with the correct entity GUID after 
        /// an application name change that results in a new entity.
        /// </summary>
        private void RecreateMetricsProvider()
        {
            Log.Debug("Recreating OTel MeterProvider due to EntityGuid change.");

            lock (_meterProviderLock)
            {
                // Dispose existing meter provider if it exists
                if (_meterProvider != null)
                {
                    _meterProvider.Dispose();
                    _meterProvider = null;
                    _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.MeterProviderRecreated);
                }

                // Create new meter provider with updated EntityGuid
                _meterProvider = CreateMeterProvider();

                if (_meterProvider != null)
                {
                    Log.Debug($"OTel MeterProvider recreated with EntityGuid: {_currentEntityGuid}");
                }
                else
                {
                    Log.Warn("Failed to recreate OTel MeterProvider: connection info not available");
                }
            }
        }

        /// <summary>
        /// Creates an HttpClient configured with proxy settings and retry logic appropriate for the target framework.
        /// </summary>
        /// <returns>HttpClient configured for OTLP export</returns>
        private HttpClient CreateHttpClientWithProxyAndRetry()
        {
            try
            {
                // Create base HttpClientHandler with proxy configuration
                var httpClientHandler = new HttpClientHandler();

                // Configure proxy if available
                if (_connectionInfo?.Proxy != null)
                {
                    Log.Debug($"Configuring OTLP exporter with proxy: {_connectionInfo.Proxy}");
                    httpClientHandler.Proxy = _connectionInfo.Proxy;
                    httpClientHandler.UseProxy = true;
                }
                else
                {
                    Log.Debug("No proxy configured for OTLP exporter");
                    httpClientHandler.UseProxy = false;
                }

#if NETSTANDARD2_0_OR_GREATER
                // For .NET Standard 2.0+: Add retry logic with exponential backoff and audit logging
                var retryHandler = new CustomRetryHandler
                {
                    InnerHandler = httpClientHandler
                };

                // Wrap the retry handler with audit logging for OTLP compliance
                var auditHandler = new OtlpAuditHandler
                {
                    InnerHandler = retryHandler
                };

                var httpClient = new HttpClient(auditHandler);
#else
                // For .NET Framework: Direct HttpClient with audit logging wrapper
                // (CustomRetryHandler uses async/await patterns that work better in .NET Standard)
                var auditHandler = new OtlpAuditHandler
                {
                    InnerHandler = httpClientHandler
                };

                var httpClient = new HttpClient(auditHandler);
#endif

                // Configure timeout (OTEL default is 10 seconds)
                httpClient.Timeout = TimeSpan.FromSeconds(DefaultOtlpTimeoutSeconds);

                // Add User-Agent for New Relic identification
                httpClient.DefaultRequestHeaders.Add("User-Agent",
                    $"NewRelic-DotNet-Agent/{AgentInstallConfiguration.AgentVersion ?? "Unknown"}");

                return httpClient;
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Failed to create HttpClient for OTLP exporter. Falling back to default HttpClient.");
                return new HttpClient();
            }
        }

        /// <summary>
        /// Stops the meter listener bridge and disposes of all resources.
        /// Cleans up the MeterListener, MeterProvider, and SDK logger.
        /// </summary>
        public void Stop()
        {
            _meterListener?.Dispose();
            _meterListener = null;

            lock (_meterProviderLock)
            {
                _meterProvider?.Dispose();
                _meterProvider = null;
            }

            _sdkLogger?.Dispose();
            _sdkLogger = null;
        }

        public override void Dispose()
        {
            Stop();

            base.Dispose();
        }

        /// <summary>
        /// Creates a MeterListener instance using the MeterListner type from the customer's application, and subscribes to the necessary hooks
        /// that allows us to bridge the Meters, Instruments, and Measurements to make them visible to our ILRepacked code.
        /// </summary>
        private void TryCreateMeterListener()
        {
            // TODO: If the logic for this method is moved to another class, and with that class we can pass in either a separate AppDomain or assembly load context or just a separate assembly, we may be able to unit test more of the bridging logic.
            var assembly = AppDomain.CurrentDomain.GetAssemblies().FirstOrDefault(a => a.GetName().Name == "System.Diagnostics.DiagnosticSource");
            if (assembly == null)
            {
                Log.Warn("System.Diagnostics.DiagnosticSource assembly not found. Cannot create MeterListener.");
                return;
            }

            var meterListenerType = assembly.GetType("System.Diagnostics.Metrics.MeterListener", throwOnError: false);
            var ilRepackedMeterListenerType = typeof(MeterListener);

            if (meterListenerType == ilRepackedMeterListenerType)
            {
                // This scenario should not happen in a customer application, but is possible in all of our
                // unit tests, because our unit tests do not run against the ilrepacked version of the agent.
                Log.Warn("MeterListener type in application matches ILRepacked MeterListener type.");
                return;
            }

            var instrumentType = assembly.GetType("System.Diagnostics.Metrics.Instrument", throwOnError: false);

            if (meterListenerType == null || instrumentType == null)
            {
                Log.Warn("Required types not found in DiagnosticSource assembly. MeterListener: {0}, Instrument: {1}",
                    meterListenerType != null, instrumentType != null);
                return;
            }

            try
            {
                _meterListener = Activator.CreateInstance(meterListenerType);

                SubscribeToInstrumentPublishedEvent(meterListenerType, instrumentType);

                SubscribeToMeasurementUpdates<byte>(meterListenerType, instrumentType);
                SubscribeToMeasurementUpdates<short>(meterListenerType, instrumentType);
                SubscribeToMeasurementUpdates<int>(meterListenerType, instrumentType);
                SubscribeToMeasurementUpdates<long>(meterListenerType, instrumentType);
                SubscribeToMeasurementUpdates<float>(meterListenerType, instrumentType);
                SubscribeToMeasurementUpdates<double>(meterListenerType, instrumentType);
                SubscribeToMeasurementUpdates<decimal>(meterListenerType, instrumentType);

                SubscribeToMeasurementCompletedEvent(meterListenerType, instrumentType);

                Log.Debug("Successfully created and configured MeterListener for OpenTelemetry bridging");
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Failed to configure MeterListener subscriptions");
                _meterListener?.Dispose();
                _meterListener = null;
                throw;
            }
        }

        /// <summary>
        /// Dynamically contructs a lambda that will be used to subscribe to the InstrumentPublished event on the MeterListener.
        ///
        /// void InstrumentPublished(Instrument instrument, MeterListener listener)
        /// {
        ///    if (MeterListenerBridge.ShouldEnableInstrumentsInMeterWithFilters(instrument.Meter.Name))
        ///    {
        ///      listener.EnableMeasurementEvents(instrument, MeterListenerBridge.GetStateForInstrument(instrument));
        ///    }
        /// }
        /// </summary>
        /// <param name="meterListenerType"> The Type representing the MeterListener class in the customer's application</param>
        /// <param name="instrumentType">The Type representing the Instrument class in the customer's application</param>
        private void SubscribeToInstrumentPublishedEvent(Type meterListenerType, Type instrumentType)
        {
            var instrumentPublishProperty = meterListenerType.GetProperty("InstrumentPublished");

            var instrumentParameter = Expression.Parameter(instrumentType, "instrument");
            var listenerParameter = Expression.Parameter(meterListenerType, "listener");

            var meterNameProperty = Expression.Property(Expression.Property(instrumentParameter, "Meter"), "Name");

            var shouldEnableMethod = typeof(MeterListenerBridge).GetMethod(nameof(ShouldEnableInstrumentsInMeterWithFilters), BindingFlags.NonPublic | BindingFlags.Instance);
            var shouldEnableCall = Expression.Call(Expression.Constant(this), shouldEnableMethod, meterNameProperty);

            var getInstrumentStateMethod = typeof(MeterListenerBridge).GetMethod(nameof(GetStateForInstrumentWithMetrics), BindingFlags.NonPublic | BindingFlags.Instance);
            var getInstrumentStateCall = Expression.Call(Expression.Constant(this), getInstrumentStateMethod, instrumentParameter);

            var enableMeasurementEventsMethod = Expression.Call(listenerParameter, "EnableMeasurementEvents", null, instrumentParameter, getInstrumentStateCall);

            var lambdaBody = Expression.IfThen(shouldEnableCall, enableMeasurementEventsMethod);

            var lambda = Expression.Lambda(instrumentPublishProperty.PropertyType, lambdaBody, instrumentParameter, listenerParameter);

            instrumentPublishProperty.SetValue(_meterListener, lambda.Compile());
        }

        /// <summary>
        /// Dynamically contructs a lambda that will be used to subscribe to the MeasurementEventCallback event and then registers the lambda
        /// as the callback on the MeterListener.
        ///
        /// void MeasurementEventCallback(Instrument instrument, T measurement, ReadOnlySpan<KeyValuePair<string, object>> tags, object state)
        /// {
        ///    MeterListenerBridge.OnMeasurementRecorded(instrument, measurement, tags, state);
        /// }
        ///
        /// _meterListener.SetMeasurementEventCallback(MeasurementEventCallback);
        /// </summary>
        /// <typeparam name="T">The Measurement Type that represents the numeric type of the value stored in a Measurement</typeparam>
        /// <param name="meterListenerType"> The Type representing the MeterListener class in the customer's application</param>
        /// <param name="instrumentType">The Type representing the Instrument class in the customer's application</param>
        private void SubscribeToMeasurementUpdates<T>(Type meterListenerType, Type instrumentType)
        {
#if NETSTANDARD
            var setMeasurementEventCallbackMethodInfo = meterListenerType.GetMethod("SetMeasurementEventCallback").MakeGenericMethod(typeof(T));
            var callbackDelegateType = setMeasurementEventCallbackMethodInfo.GetParameters()[0].ParameterType;

            // Extract parameter types from the customer's delegate to avoid type identity issues
            // The delegate's Invoke method signature tells us the exact types expected from the customer's assembly
            var delegateParameters = callbackDelegateType.GetMethod("Invoke").GetParameters();

            var instrumentParameter = Expression.Parameter(delegateParameters[0].ParameterType, "instrument");
            var measurementParameter = Expression.Parameter(delegateParameters[1].ParameterType, "measurement");
            var tagsParameter = Expression.Parameter(delegateParameters[2].ParameterType, "tags");
            var stateParameter = Expression.Parameter(delegateParameters[3].ParameterType, "state");

            // Convert ReadOnlySpan<KeyValuePair<string, object>> to array if needed
            Expression tagsArrayExpr = tagsParameter;
            var roSpanType = typeof(ReadOnlySpan<>).MakeGenericType(typeof(KeyValuePair<string, object>));
            if (tagsParameter.Type == roSpanType)
            {
                var toArrayMethod = typeof(MeterListenerBridge).GetMethod(nameof(ToArray), BindingFlags.NonPublic | BindingFlags.Static);
                tagsArrayExpr = Expression.Call(toArrayMethod, tagsParameter);
            }

            var onMeasurementRecordedMethod = typeof(MeterListenerBridge)
                .GetMethod(nameof(OnMeasurementRecorded), BindingFlags.NonPublic | BindingFlags.Instance)
                .MakeGenericMethod(typeof(T));

            var methodCall = Expression.Call(
                Expression.Constant(this),
                onMeasurementRecordedMethod,
                instrumentParameter,
                measurementParameter,
                tagsArrayExpr,
                stateParameter);

            var measurementRecordedLambda = Expression.Lambda(callbackDelegateType, methodCall, instrumentParameter, measurementParameter, tagsParameter, stateParameter);
            setMeasurementEventCallbackMethodInfo.Invoke(_meterListener, new object[] { measurementRecordedLambda.Compile() });
#else
            try
            {

                var setMeasurementEventCallbackMethodInfo = meterListenerType.GetMethod("SetMeasurementEventCallback").MakeGenericMethod(typeof(T));

                // Build a callback using the customer's delegate signature that copies the customer's ReadOnlySpan to an array
                var dynamicCallback = CreateOnMeasurementRecordedWedgeDynamic<T>(meterListenerType);

                // Register the generated callback with the customer's MeterListener
                setMeasurementEventCallbackMethodInfo.Invoke(_meterListener, new object[] { dynamicCallback });
            }
            catch (Exception e)
            {
                var foo = e.ToString();
                Console.WriteLine(foo);
                throw;
            }
#endif
        }

#if NETFRAMEWORK
        public Delegate CreateOnMeasurementRecordedWedgeDynamic<T>(Type customerMeterListenerType)
        {
            var setCallback = customerMeterListenerType.GetMethod("SetMeasurementEventCallback").MakeGenericMethod(typeof(T));
            var callbackDelegateType = setCallback.GetParameters()[0].ParameterType;

            var invokeParams = callbackDelegateType.GetMethod("Invoke").GetParameters();
            var instrumentParamType = invokeParams[0].ParameterType;
            var measurementParamType = invokeParams[1].ParameterType;
            var customerSpanParamType = invokeParams[2].ParameterType;
            var stateParamType = invokeParams[3].ParameterType;

            var getItem = customerSpanParamType.GetMethod("get_Item", new[] { typeof(int) });
            var customerByRefKvpType = getItem?.ReturnType;
            var customerKvpType = customerByRefKvpType != null && customerByRefKvpType.IsByRef
                ? customerByRefKvpType.GetElementType()
                : typeof(KeyValuePair<string, object>);

            // Resolve agent KVP type from Core if available
            Type agentKvpType;
            var coreAsm = AppDomain.CurrentDomain.GetAssemblies().FirstOrDefault(a => string.Equals(a.GetName().Name, "NewRelic.Agent.Core", StringComparison.Ordinal));
            if (coreAsm != null)
            {
                var kvpDef = coreAsm.GetType("System.Collections.Generic.KeyValuePair`2", throwOnError: false);
                agentKvpType = kvpDef != null ? kvpDef.MakeGenericType(typeof(string), typeof(object)) : typeof(KeyValuePair<string, object>);
            }
            else
            {
                agentKvpType = typeof(KeyValuePair<string, object>);
            }

            // Create an open dynamic method (no target bound) matching the customer delegate signature
            var dm = new DynamicMethod("OnMeasurementRecordedWedge_IL", typeof(void),
                new[] { instrumentParamType, measurementParamType, customerSpanParamType, stateParamType }, typeof(MeterListenerBridge).Module, true);
            var il = dm.GetILGenerator();

            var lenLocal = il.DeclareLocal(typeof(int));
            var arrLocal = il.DeclareLocal(agentKvpType.MakeArrayType());
            var iLocal = il.DeclareLocal(typeof(int));
            var customerKvpLocal = il.DeclareLocal(customerKvpType); // local to hold copied KVP value

            // len = tags.Length
            var lengthProp = customerSpanParamType.GetProperty("Length");
            il.Emit(OpCodes.Ldarg_2);
            il.Emit(OpCodes.Call, lengthProp.GetGetMethod());
            il.Emit(OpCodes.Stloc, lenLocal);

            // arr = new agentKVP[len]
            il.Emit(OpCodes.Ldloc, lenLocal);
            il.Emit(OpCodes.Newarr, agentKvpType);
            il.Emit(OpCodes.Stloc, arrLocal);

            // i = 0
            il.Emit(OpCodes.Ldc_I4_0);
            il.Emit(OpCodes.Stloc, iLocal);

            var loopCheck = il.DefineLabel();
            var loopStart = il.DefineLabel();
            il.Emit(OpCodes.Br_S, loopCheck);

            il.MarkLabel(loopStart);
            // arr[i] = new agentKvp(tags[i].Key, tags[i].Value)
            il.Emit(OpCodes.Ldloc, arrLocal);      // arr
            il.Emit(OpCodes.Ldloc, iLocal);        // i
            il.Emit(OpCodes.Ldarg_2);              // tags
            il.Emit(OpCodes.Ldloc, iLocal);        // i
            il.Emit(OpCodes.Call, getItem);        // by-ref KVP
            // copy by-ref struct to local value: ldobj customerKvpType; stloc customerKvpLocal
            il.Emit(OpCodes.Ldobj, customerKvpType);
            il.Emit(OpCodes.Stloc, customerKvpLocal);
            // load local address and call getters on valuetype
            il.Emit(OpCodes.Ldloca_S, customerKvpLocal);
            var keyGetter = customerKvpType.GetProperty("Key").GetGetMethod();
            il.Emit(OpCodes.Call, keyGetter);
            il.Emit(OpCodes.Ldloca_S, customerKvpLocal);
            var valueGetter = customerKvpType.GetProperty("Value").GetGetMethod();
            il.Emit(OpCodes.Call, valueGetter);
            var agentKvpCtor = agentKvpType.GetConstructor(new[] { typeof(string), typeof(object) });
            il.Emit(OpCodes.Newobj, agentKvpCtor);
            il.Emit(OpCodes.Stelem, agentKvpType);

            il.Emit(OpCodes.Ldloc, iLocal);
            il.Emit(OpCodes.Ldc_I4_1);
            il.Emit(OpCodes.Add);
            il.Emit(OpCodes.Stloc, iLocal);

            il.MarkLabel(loopCheck);
            il.Emit(OpCodes.Ldloc, iLocal);
            il.Emit(OpCodes.Ldloc, lenLocal);
            il.Emit(OpCodes.Clt);
            il.Emit(OpCodes.Brtrue_S, loopStart);

            // Load bridge instance from static and call instance method
            var bridgeField = typeof(MeterListenerBridge).GetField("_bridgeInstance", BindingFlags.NonPublic | BindingFlags.Static);
            il.Emit(OpCodes.Ldsfld, bridgeField);
            il.Emit(OpCodes.Ldarg_0); // instrument -> object
            if (instrumentParamType.IsValueType)
            {
                il.Emit(OpCodes.Box, instrumentParamType);
            }
            il.Emit(OpCodes.Ldarg_1); // measurement
            il.Emit(OpCodes.Ldloc, arrLocal); // tags (array)
            il.Emit(OpCodes.Ldarg_3); // state

            var onRecorded = typeof(MeterListenerBridge)
                .GetMethod("OnMeasurementRecorded", BindingFlags.NonPublic | BindingFlags.Instance)
                .MakeGenericMethod(typeof(T));
            il.Emit(OpCodes.Call, onRecorded);
            il.Emit(OpCodes.Ret);

            return dm.CreateDelegate(callbackDelegateType);
        }
#endif
        /// <summary>
        /// Dynamically contructs a lambda that will be used to subscribe to the MeasurementsCompleted event and then registers the lambda
        /// with the MeterListener.
        ///
        /// void MeasurementsCompleted(Instrument instrument, object state)
        /// {
        ///    MeterListenerBridge.DisableBridgedInstrument(state);
        /// }
        ///
        /// _meterListener.MeasurementsCompleted = MeasurementsCompleted;
        /// </summary>
        /// <param name="meterListenerType"> The Type representing the MeterListener class in the customer's application</param>
        /// <param name="instrumentType">The Type representing the Instrument class in the customer's application</param>
        private void SubscribeToMeasurementCompletedEvent(Type meterListenerType, Type instrumentType)
        {
            var measurementsCompletedProperty = meterListenerType.GetProperty("MeasurementsCompleted");

            var instrumentParameter = Expression.Parameter(instrumentType, "instrument");
            var stateParameter = Expression.Parameter(typeof(object), "state");

            var disableBridgedInstrumentMethod = typeof(MeterListenerBridge).GetMethod(nameof(DisableBridgedInstrument), BindingFlags.NonPublic | BindingFlags.Static);
            var disableBridgedInstrumentCall = Expression.Call(null, disableBridgedInstrumentMethod, stateParameter);

            var measurmentsCompletedLambda = Expression.Lambda(measurementsCompletedProperty.PropertyType, disableBridgedInstrumentCall, instrumentParameter, stateParameter);

            measurementsCompletedProperty.SetValue(_meterListener, measurmentsCompletedLambda.Compile());
        }

        private static void DisableBridgedInstrument(object state)
        {
            if (state == null)
            {
                return;
            }

            var bridgedInstrument = state as Instrument;
            if (bridgedInstrument == null)
            {
                return;
            }

            // The MeasurementsCompleted event is triggered when an instrument is no longer being subscribed to by a MeterListener
            // or the Meter holding the instrumented is Disposed. In our use case, we subscribe to all instruments in a meter and
            // do not disable individual individual instruments, so the only way this event will be triggered is if the corresponding
            // meter is no longer being used by the application or if our MeterListener is being Disposed. In either case we can
            // just Dispose of the bridged Meter.

            if (_bridgedMeters.TryRemove(bridgedInstrument.Meter.Name, out var bridgedMeter))
            {
                var meterName = bridgedMeter.Name;
                bridgedMeter.Dispose();
                Log.Debug($"Disposed bridged meter: {meterName}");
            }
        }


        private static bool ShouldEnableInstrumentsInMeter(string meterName)
        {
            // TODO: If the agent ever targets .net 9 the .net 9 build of the agent will not need to bridge the runtime metrics meter that is
            // built into the diagnostics source library. This check will need to be updated to not bridge the runtime metrics meter.

            // Skip internal diagnostic meters to avoid potential recursion
            if (string.IsNullOrEmpty(meterName))
            {
                return false;
            }

            // Filter out internal infrastructure meters that could cause recursion
            if (meterName.StartsWith("NewRelic", StringComparison.OrdinalIgnoreCase) ||
                meterName.StartsWith("OpenTelemetry", StringComparison.OrdinalIgnoreCase) ||
                meterName.StartsWith("System.Diagnostics" + ".Metrics", StringComparison.OrdinalIgnoreCase))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Determines whether instruments in the specified meter should be enabled based on the 
        /// OpenTelemetry metrics configuration filters (include/exclude lists).
        /// Follows the precedence logic:
        /// 1. Built-in exclude list
        /// 2. Customer configured include list  
        /// 3. Customer configured exclude list
        /// </summary>
        /// <param name="meterName">The name of the meter to check</param>
        /// <returns>True if the meter should be enabled; false otherwise</returns>
        private bool ShouldEnableInstrumentsInMeterWithFilters(string meterName)
        {
            // First apply the built-in filtering logic
            if (!ShouldEnableInstrumentsInMeter(meterName))
            {
                return false;
            }

            // Check if OpenTelemetry metrics + global OpenTelemetry are enabled
            if (!_configuration.OpenTelemetryMetricsEnabled)
            {
                return false;
            }

            var includeFilters = _configuration.OpenTelemetryMetricsIncludeFilters?.ToList() ?? new List<string>();
            var excludeFilters = _configuration.OpenTelemetryMetricsExcludeFilters?.ToList() ?? new List<string>();

            // If include filters are specified, the meter must be in the include list
            if (includeFilters.Any() && !includeFilters.Contains(meterName))
            {
                Log.Finest($"Meter '{meterName}' not in include list. Not enabling instruments.");
                return false;
            }

            // If the meter is in the exclude list, don't enable it
            if (excludeFilters.Contains(meterName))
            {
                Log.Finest($"Meter '{meterName}' is in exclude list. Not enabling instruments.");
                return false;
            }

            Log.Finest($"Meter '{meterName}' passed all filters. Enabling instruments.");
            return true;
        }

        /// <summary>
        /// Creates the bridged Meters and Instruments, and returns the state object that can be used by the other callbacks triggered by
        /// the MeterListener.
        /// </summary>
        /// <param name="instrument">The original Instrument instance</param>
        /// <returns>The state object the MeterListener should use for each Instrument callback. This value is either null or the bridged
        /// Instrument' instance corresponding to the original instrument.</returns>
        private static object GetStateForInstrument(object instrument)
        {
            // Use reflection instead of dynamic to avoid runtime binder issues across mixed assemblies
            var instrumentType = instrument.GetType();
            var genericType = instrumentType.GetGenericArguments().FirstOrDefault();
            if (genericType == null)
            {
                return null;
            }

            // Resolve commonly used properties via reflection
            var meterProp = instrumentType.GetProperty("Meter");
            var nameProp = instrumentType.GetProperty("Name");
            var unitProp = instrumentType.GetProperty("Unit");
            var descProp = instrumentType.GetProperty("Description");
            var isObservableProp = instrumentType.GetProperty("IsObservable");

            var meterObj = meterProp?.GetValue(instrument);
            var meterName = meterObj?.GetType().GetProperty("Name")?.GetValue(meterObj) as string;

            // Create or get bridged meter using the concrete meter name
            Meter meter = null;
            if (!string.IsNullOrEmpty(meterName))
            {
                meter = _bridgedMeters.GetOrAdd(meterName, (Func<string, Meter>)CreateBridgedMeterFromInstrument);
            }
            else
            {
                // Fallback create directly if name missing
                meter = CreateBridgedMeter(meterObj);
            }

            var isObservable = (bool?)isObservableProp?.GetValue(instrument) ?? false;
            if (isObservable)
            {
                var cacheData = _createObservableInstrumentCache.GetOrAdd(instrumentType, GetObservableInstrumentCacheData);
                if (cacheData == null)
                {
                    return null;
                }

                var createCallbackAndObservableInstrument = cacheData.CreateCallbackAndObservableInstrumentDelegate;
                var observableResult = createCallbackAndObservableInstrument(instrument, meter, cacheData);
                return observableResult;
            }

            var createInstrumentDelegate = (Func<Meter, string, string, string, IEnumerable<KeyValuePair<string, object>>, object>)_createInstrumentDelegates.GetOrAdd(instrumentType, CreateBridgedInstrumentDelegate);
            if (createInstrumentDelegate == null)
            {
                return null;
            }

            // Try to get Tags from the instrument if available (DiagnosticSource 8.0+)
            IEnumerable<KeyValuePair<string, object>> instrumentTags = null;
            var tagsProperty = instrumentType.GetProperty("Tags");
            if (tagsProperty != null)
            {
                try
                {
                    var tagsValue = tagsProperty.GetValue(instrument);
                    if (tagsValue != null)
                    {
                        var tagsList = new List<KeyValuePair<string, object>>();
                        foreach (var tag in (IEnumerable)tagsValue)
                        {
                            var tagType = tag.GetType();
                            var key = (string)tagType.GetProperty("Key")?.GetValue(tag);
                            var value = tagType.GetProperty("Value")?.GetValue(tag) ?? string.Empty;
                            tagsList.Add(new KeyValuePair<string, object>(key, value));
                        }
                        if (tagsList.Count > 0)
                        {
                            instrumentTags = tagsList;
                            Log.Finest($"Bridged {tagsList.Count} tags from instrument '{nameProp?.GetValue(instrument)}'");
                        }
                    }
                }
                catch (Exception ex)
                {
                    Log.Debug(ex, $"Failed to bridge Tags from instrument '{nameProp?.GetValue(instrument)}'. Continuing without tags.");
                }
            }

            var name = nameProp?.GetValue(instrument) as string;
            var unit = unitProp?.GetValue(instrument) as string;
            var description = descProp?.GetValue(instrument) as string;

            var result = createInstrumentDelegate.Invoke(meter, name, unit, description, instrumentTags);
            return result;

            Meter CreateBridgedMeterFromInstrument(string _)
            {
                // Avoid dynamic in closure to prevent runtime binder issues
                return CreateBridgedMeter(meterObj);
            }
        }

        /// <summary>
        /// Instance method that wraps GetStateForInstrument with supportability metric tracking
        /// </summary>
        /// <param name="instrument">The original Instrument instance</param>
        /// <returns>The state object for the MeterListener callbacks</returns>
        private object GetStateForInstrumentWithMetrics(object instrument)
        {
            // Record getMeter usage
            _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.GetMeter);

            // Get the result from the static method
            var result = GetStateForInstrument(instrument);

            if (result != null)
            {
                _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.InstrumentCreated);

                // Track specific instrument type
                var instrumentType = instrument.GetType();
                RecordSpecificInstrumentType(instrumentType.Name);
            }
            else
            {
                _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.InstrumentBridgeFailure);
            }

            return result;
        }

        /// <summary>
        /// Record supportability metrics for specific instrument types
        /// </summary>
        /// <param name="instrumentTypeName">The name of the instrument type</param>
        private void RecordSpecificInstrumentType(string instrumentTypeName)
        {
            switch (instrumentTypeName)
            {
                case "Counter`1":
                    _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.CreateCounter);
                    break;
                case "Histogram`1":
                    _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.CreateHistogram);
                    break;
                case "UpDownCounter`1":
                    _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.CreateUpDownCounter);
                    break;
                case "Gauge`1":
                    _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.CreateGauge);
                    break;
                case "ObservableCounter`1":
                    _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.CreateObservableCounter);
                    break;
                case "ObservableGauge`1":
                    _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.CreateObservableGauge);
                    break;
                case "ObservableUpDownCounter`1":
                    _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.CreateObservableUpDownCounter);
                    break;
                case "ObservableHistogram`1":
                    _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.CreateObservableHistogram);
                    break;
            }
        }

        private static ObservableInstrumentCacheData GetObservableInstrumentCacheData(Type instrumentType)
        {
            var genericType = instrumentType.GetGenericArguments().FirstOrDefault();
            if (genericType == null)
            {
                return null;
            }

            var cacheData = new ObservableInstrumentCacheData();
            cacheData.CreateObservableInstrumentDelegate = CreateBridgedObservableInstrumentDelegate(instrumentType);
            cacheData.CreateCallbackAndObservableInstrumentDelegate = CreateCallbackAndBridgedObservableInstrumentAction(instrumentType);
            cacheData.ObserveMethodDelegate = CreateObserveMethodInvoker(instrumentType);

            return cacheData;
        }

        /// <summary>
        /// Creates a delegate that can be used to invoke the internal Observe() method on an Observable Instrument instance.
        ///
        /// IEnumerable InvokeObserveMethod(object instrument)
        /// {
        ///    var typedInstrument = (InstrumentType)instrument;
        ///    return (IEnumerable)typedInstrument.Observe();
        /// }
        /// </summary>
        /// <param name="instrumentType">The Type representing the Instrument class in the customer's application</param>
        /// <returns></returns>
        public static Func<object, IEnumerable> CreateObserveMethodInvoker(Type instrumentType)
        {
            var observeMethod = instrumentType.GetMethod("Observe", BindingFlags.NonPublic | BindingFlags.Instance, null, Type.EmptyTypes, null);
            var instrumentParameter = Expression.Parameter(typeof(object), "instrument");
            var typedInstrument = Expression.Convert(instrumentParameter, instrumentType);
            var observeMethodCall = Expression.Call(typedInstrument, observeMethod);
            var convertedResult = Expression.Convert(observeMethodCall, typeof(IEnumerable));
            var lambda = Expression.Lambda<Func<object, IEnumerable>>(convertedResult, instrumentParameter);

            return lambda.Compile();
        }

        private static Func<object, Meter, ObservableInstrumentCacheData, Instrument> CreateCallbackAndBridgedObservableInstrumentAction(Type instrumentType)
        {
            var genericType = instrumentType.GetGenericArguments().FirstOrDefault();
            var methodInfo = typeof(MeterListenerBridge).GetMethod(nameof(CreateCallbackAndBridgedObservableInstrument), BindingFlags.NonPublic | BindingFlags.Static).MakeGenericMethod(genericType);
            return (Func<object, Meter, ObservableInstrumentCacheData, Instrument>)methodInfo.CreateDelegate(typeof(Func<object, Meter, ObservableInstrumentCacheData, Instrument>));
        }

        private static Instrument CreateCallbackAndBridgedObservableInstrument<T>(object instrument, Meter meter, ObservableInstrumentCacheData cacheData) where T : struct
        {
            var createObservableInstrument = (CreateObservableInstrumentDelegate<T>)cacheData.CreateObservableInstrumentDelegate;
            if (createObservableInstrument == null)
            {
                return null;
            }

            // Use reflection to avoid dynamic runtime binder issues across mixed assemblies
            var instType = instrument.GetType();
            var nameProp = instType.GetProperty("Name");
            var unitProp = instType.GetProperty("Unit");
            var descProp = instType.GetProperty("Description");
            var name = (string)nameProp?.GetValue(instrument);
            var unit = (string)unitProp?.GetValue(instrument);
            var description = (string)descProp?.GetValue(instrument);

            // Need to create a function that can call the Observe() method on the instrument (the protected parameterless method)
            // and transform the IEnumerable<Measurement<T>> into the bridged IEnumerable<Measurement<T>> that the ilrepacked code expects
            var observeMethod = cacheData.ObserveMethodDelegate;
            return createObservableInstrument(meter, name, ForwardObservedMeasurements, unit, description);

            IEnumerable<Measurement<T>> ForwardObservedMeasurements()
            {
                return BridgeMeasurements<T>(observeMethod(instrument));
            }
        }

        private static IEnumerable<Measurement<T>> BridgeMeasurements<T>(IEnumerable originalMeasurements) where T : struct
        {
            var bridgedMeasurements = new List<Measurement<T>>();
            Func<object, Measurement<T>> createBridgedMeasurement = null;
            foreach (var measurement in originalMeasurements)
            {
                // Initializing the delegate to create the bridged measurment within the loop because the type of the original measurements
                // is not IEnumerable<Measurement<T>> but is the concrete collection instead (which may change in the future).
                if (createBridgedMeasurement == null)
                {
                    createBridgedMeasurement = (Func<object, Measurement<T>>)_bridgeMeasurementDelegates.GetOrAdd(measurement.GetType(), GetMethodToBridgeMeasurement<T>);
                }
                bridgedMeasurements.Add(createBridgedMeasurement(measurement));
            }

            return bridgedMeasurements;
        }

        /// <summary>
        /// Dynamically creates a delegate that can be used to bridge the Measurement instances from the customer's application to the ILRepacked
        /// Measurement' instances. The Tags on a Measurement are a special type that cannot be stored or referenced using object variables
        /// or the dynamic type system. We need to dynamically create a strongly typed method that can access these values so that they can be
        /// bridged.
        ///
        /// Measurement<T> BridgeMeasurement<T>(object originalMeasurement)
        /// {
        ///    var typedMeasurement = (OriginalMeasurementType)originalMeasurement;
        ///    var bridgedMeasurement = new Measurement<T>(typedMeasurement.Value, typedMeasurement.Tags);
        /// }
        /// </summary>
        /// <typeparam name="T">The Measurement Type that represents the numeric type of the value stored in a Measurement</typeparam>
        /// <param name="originalMeasurementType">The Type that represents the original Measurement type from the customer's application</param>
        /// <returns>A delegate that takes the original Measurement instance and returns a bridged Measurement' instance</returns>
        private static Func<object, Measurement<T>> GetMethodToBridgeMeasurement<T>(Type originalMeasurementType) where T : struct
        {
#if NETSTANDARD
            var measurementConstructor = typeof(Measurement<T>).GetConstructor([typeof(T), typeof(ReadOnlySpan<KeyValuePair<string, object>>)]);
            if (measurementConstructor == null)
            {
                return null;
            }

            var originalMeasurementParameter = Expression.Parameter(typeof(object), "originalMeasurement");
            var typedOriginalMeasurement = Expression.Convert(originalMeasurementParameter, originalMeasurementType);

            var valuePropertyAccess = Expression.Property(typedOriginalMeasurement, originalMeasurementType, "Value");
            var tagsPropertyAccess = Expression.Property(typedOriginalMeasurement, originalMeasurementType, "Tags");

            var newMeasurement = Expression.New(measurementConstructor, valuePropertyAccess, tagsPropertyAccess);
            var lambda = Expression.Lambda<Func<object, Measurement<T>>>(newMeasurement, originalMeasurementParameter);

            return lambda.Compile();
#else

            // Build a runtime delegate that copies customer's Tags (ReadOnlySpan<customerKvp>) to
            // agent KeyValuePair<string, object>[] and constructs Measurement<T>(value, tagsArray).
            return (object originalMeasurement) =>
            {
                if (originalMeasurement == null)
                {
                    return default;
                }

                // Get value and tags via reflection to avoid dynamic binder issues
                var valueProp = originalMeasurementType.GetProperty("Value");
                var tagsProp = originalMeasurementType.GetProperty("Tags");
                var valueObj = valueProp?.GetValue(originalMeasurement);
                var tagsSpanObj = tagsProp?.GetValue(originalMeasurement);

                // Convert measurement value to T
                var value = (T)Convert.ChangeType(valueObj, typeof(T));

                // Default empty tags
                KeyValuePair<string, object>[] agentTagsArray = Array.Empty<KeyValuePair<string, object>>();

                if (tagsSpanObj != null)
                {
                    var spanType = tagsSpanObj.GetType();
                    // Length
                    var lengthProp = spanType.GetProperty("Length");
                    var len = (int)(lengthProp?.GetValue(tagsSpanObj) ?? 0);

                    if (len > 0)
                    {
                        // Determine customer KVP type from indexer return (by-ref)
                        var getItem = spanType.GetMethod("get_Item", new[] { typeof(int) });
                        var byRefKvpType = getItem?.ReturnType;
                        var customerKvpType = byRefKvpType != null && byRefKvpType.IsByRef ? byRefKvpType.GetElementType() : null;

                        // Resolve agent KVP type (prefer Core if present)
                        Type agentKvpType;
                        var coreAsm = AppDomain.CurrentDomain.GetAssemblies().FirstOrDefault(a => string.Equals(a.GetName().Name, "NewRelic.Agent.Core", StringComparison.Ordinal));
                        if (coreAsm != null)
                        {
                            var kvpDef = coreAsm.GetType("System.Collections.Generic.KeyValuePair`2", throwOnError: false);
                            agentKvpType = kvpDef != null ? kvpDef.MakeGenericType(typeof(string), typeof(object)) : typeof(KeyValuePair<string, object>);
                        }
                        else
                        {
                            agentKvpType = typeof(KeyValuePair<string, object>);
                        }

                        agentTagsArray = (KeyValuePair<string, object>[])Array.CreateInstance(agentKvpType, len);

                        var keyGetter = customerKvpType?.GetProperty("Key")?.GetGetMethod();
                        var valueGetter = customerKvpType?.GetProperty("Value")?.GetGetMethod();
                        var agentCtor = agentKvpType.GetConstructor(new[] { typeof(string), typeof(object) });

                        for (int i = 0; i < len; i++)
                        {
                            // Access by-ref customer KVP via indexer
                            var kvpByRef = getItem.Invoke(tagsSpanObj, new object[] { i });
                            // kvpByRef is boxed; call Key/Value getters via reflection
                            var key = (string)keyGetter.Invoke(kvpByRef, null);
                            var objVal = valueGetter.Invoke(kvpByRef, null);
                            var agentKvp = (KeyValuePair<string, object>)agentCtor.Invoke(new object[] { key, objVal ?? string.Empty });
                            agentTagsArray[i] = agentKvp;
                        }
                    }
                }

                // Construct bridged Measurement with array (will be consumed as ReadOnlySpan by overload)
                return new Measurement<T>(value, agentTagsArray);
            };
#endif
        }

        private static Func<Meter, string, string, string, IEnumerable<KeyValuePair<string, object>>, object> CreateBridgedInstrumentDelegate(Type originalInstrumentType)
        {
            var genericType = originalInstrumentType.GetGenericArguments().FirstOrDefault();
            if (genericType == null)
            {
                return null;
            }

            var createInstrumentMethodName = originalInstrumentType.Name switch
            {
                "Counter`1" => "CreateCounter",
                "Histogram`1" => "CreateHistogram",
                "UpDownCounter`1" => "CreateUpDownCounter",
                "Gauge`1" => "CreateGauge",
                _ => null
            };

            if (createInstrumentMethodName == null)
            {
                return null;
            }

            // Reflection logic for Meter.Create* methods:
            // 1. Try to match the latest public OTel signature (4 parameters: name, unit, description, tags)
            // 2. Fallback to 3-parameter version (name, unit, description) for backward compatibility
            // 3. Always match by parameter types, not just count
            // 4. If neither found, return null (fail fast in tests)
            // See: https://github.com/dotnet/runtime/blob/main/src/libraries/System.Diagnostics.DiagnosticSource/src/System/Diagnostics/Metrics/Meter.cs
            MethodInfo methodInfo = null;
            try
            {
                // Try 4-parameter overload (name, unit, description, tags)
                methodInfo = typeof(Meter).GetMethods()
                    .FirstOrDefault(m =>
                        m.Name == createInstrumentMethodName &&
                        m.IsGenericMethod &&
                        m.GetParameters().Select(p => p.ParameterType)
                            .SequenceEqual(new[] { typeof(string), typeof(string), typeof(string), typeof(IEnumerable<KeyValuePair<string, object>>) })
                    );
                if (methodInfo != null)
                {
                    methodInfo = methodInfo.MakeGenericMethod(genericType);
                    // Use the 4-parameter overload and pass through the tags
                    return (meter, name, unit, description, tags) => methodInfo.Invoke(meter, new object[] { name, unit, description, tags });
                }

                // Fallback: Try 3-parameter overload (name, unit, description)
                methodInfo = typeof(Meter).GetMethods()
                    .FirstOrDefault(m =>
                        m.Name == createInstrumentMethodName &&
                        m.IsGenericMethod &&
                        m.GetParameters().Select(p => p.ParameterType)
                            .SequenceEqual(new[] { typeof(string), typeof(string), typeof(string) })
                    );

                if (methodInfo == null)
                {
                    return null;
                }

                methodInfo = methodInfo.MakeGenericMethod(genericType);
                // Fallback to 3-parameter version, ignoring tags
                return (meter, name, unit, description, tags) => methodInfo.Invoke(meter, new object[] { name, unit, description });
            }
            catch (Exception ex)
            {
                Log.Error($"Failed to create bridged instrument delegate for {originalInstrumentType.Name}: {ex}");
                return null;
            }
        }

        private static Delegate CreateBridgedObservableInstrumentDelegate(Type originalInstrumentType)
        {
            var genericType = originalInstrumentType.GetGenericArguments().FirstOrDefault();
            if (genericType == null)
            {
                return null;
            }

            var createInstrumentMethodName = originalInstrumentType.Name switch
            {
                "ObservableCounter`1" => nameof(CreateBridgedObservableCounter),
                "ObservableGauge`1" => nameof(CreateBridgedObservableGauge),
                "ObservableUpDownCounter`1" => nameof(CreateBridgedObservableUpDownCounter),
                _ => null
            };

            if (createInstrumentMethodName == null)
            {
                return null;
            }

            var delegateType = typeof(CreateObservableInstrumentDelegate<>).MakeGenericType(genericType);
            var methodInfo = typeof(MeterListenerBridge).GetMethod(createInstrumentMethodName, BindingFlags.NonPublic | BindingFlags.Static)?.MakeGenericMethod(genericType);
            if (methodInfo == null)
            {
                return null;
            }

            var createDelegate = methodInfo.CreateDelegate(delegateType);
            return createDelegate;
        }

        private delegate Instrument CreateObservableInstrumentDelegate<T>(Meter meter, string name, Func<IEnumerable<Measurement<T>>> callback, string unit, string description) where T : struct;

        private static Instrument CreateBridgedObservableCounter<T>(Meter meter, string name, Func<IEnumerable<Measurement<T>>> callback, string unit, string description) where T : struct
        {
            return meter.CreateObservableCounter(name, callback, unit, description);
        }

        private static Instrument CreateBridgedObservableGauge<T>(Meter meter, string name, Func<IEnumerable<Measurement<T>>> callback, string unit, string description) where T : struct
        {
            return meter.CreateObservableGauge(name, callback, unit, description);
        }

        private static Instrument CreateBridgedObservableUpDownCounter<T>(Meter meter, string name, Func<IEnumerable<Measurement<T>>> callback, string unit, string description) where T : struct
        {
            return meter.CreateObservableUpDownCounter(name, callback, unit, description);
        }

        private static Meter CreateBridgedMeter(object meter)
        {
            // Use reflection instead of dynamic to avoid runtime binder issues across mixed assemblies
            if (meter == null)
            {
                return null;
            }

            var meterType = meter.GetType();
            var nameProp = meterType.GetProperty("Name");
            var versionProp = meterType.GetProperty("Version");
            var tagsProp = meterType.GetProperty("Tags");
            var scopeProp = meterType.GetProperty("Scope");

            var name = (string)nameProp?.GetValue(meter);
            var version = (string)versionProp?.GetValue(meter);

            // Try to get Tags property if it exists (available in DiagnosticSource 8.0+)
            IEnumerable<KeyValuePair<string, object>> tags = null;
            if (tagsProp != null)
            {
                try
                {
                    var tagsValue = tagsProp.GetValue(meter);
                    if (tagsValue != null)
                    {
                        var tagsList = new List<KeyValuePair<string, object>>();
                        foreach (var tag in (IEnumerable)tagsValue)
                        {
                            var tagType = tag.GetType();
                            var key = (string)tagType.GetProperty("Key")?.GetValue(tag);
                            var value = tagType.GetProperty("Value")?.GetValue(tag) ?? string.Empty;
                            tagsList.Add(new KeyValuePair<string, object>(key, value));
                        }
                        if (tagsList.Count > 0)
                        {
                            tags = tagsList;
                            Log.Finest($"Bridged {tagsList.Count} tags from meter '{name}'");
                        }
                    }
                }
                catch (Exception ex)
                {
                    Log.Debug(ex, $"Failed to bridge Tags from meter '{name}'. Continuing without tags.");
                }
            }

            // Try to get Scope property if it exists (available in DiagnosticSource 8.0+)
            object scope = null;
            if (scopeProp != null)
            {
                try
                {
                    scope = scopeProp.GetValue(meter);
                    if (scope != null)
                    {
                        Log.Finest($"Bridged scope from meter '{name}': {scope}");
                    }
                }
                catch (Exception ex)
                {
                    Log.Debug(ex, $"Failed to bridge Scope from meter '{name}'. Continuing without scope.");
                }
            }

            // Create bridged meter with available properties
            if (tags != null || scope != null)
            {
                return new Meter(name, version, tags, scope);
            }
            else
            {
                return new Meter(name, version);
            }
        }

        private void OnMeasurementRecorded<T>(object instrument, T measurement, KeyValuePair<string, object>[] tags, object state)
            where T : struct
        {
            try
            {
                if (state == null)
                {
                    return;
                }

                // Record that a measurement was successfully recorded
                _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.MeasurementRecorded);

                // Record that a measurement was successfully bridged
                switch (state)
                {
                    case Counter<T> counter:
                        counter.Add(measurement, tags);
                        Log.Finest($"Bridged measurement {measurement} to counter {counter.Meter.Name}.{counter.Name}");
                        break;
                    case Histogram<T> histogram:
                        histogram.Record(measurement, tags);
                        Log.Finest($"Bridged measurement {measurement} to histogram {histogram.Meter.Name}.{histogram.Name}");
                        break;
                    case UpDownCounter<T> upDownCounter:
                        upDownCounter.Add(measurement, tags);
                        Log.Finest($"Bridged measurement {measurement} to upDownCounter {upDownCounter.Meter.Name}.{upDownCounter.Name}");
                        break;
                    // TODO: Add support for Gauge<T> and remove the gauge logic from the default case.
                    default:
                        // Runtime support for Gauge<T> (for .NET 8+) even if compiled against older frameworks
                        var stateType = state.GetType();
                        if (stateType.Name.StartsWith("Gauge`1"))
                        {
                            var recordMethod = stateType.GetMethod("Record", new[] { typeof(T), typeof(ReadOnlySpan<KeyValuePair<string, object>>) })
                                                ?? stateType.GetMethod("Record", new[] { typeof(T), typeof(TagList) });
                            if (recordMethod != null)
                            {
                                // ReadOnlySpan<T> cannot be boxed, so convert to array for reflection
                                recordMethod.Invoke(state, new object[] { measurement, tags.ToArray() });
                                var meterProp = stateType.GetProperty("Meter");
                                var nameProp = stateType.GetProperty("Name");
                                var meterName = meterProp?.GetValue(state)?.GetType().GetProperty("Name")?.GetValue(meterProp.GetValue(state));
                                var gaugeName = nameProp?.GetValue(state);
                                Log.Finest($"Bridged measurement {measurement} to gauge {meterName}.{gaugeName}");
                                break;
                            }
                        }
                        Log.Debug($"Unsupported instrument type for measurement bridging: {stateType.Name}");
                        break;
                }
            }
            catch (Exception ex)
            {
                _supportabilityMetricCounters?.Record(OtelBridgeSupportabilityMetric.MeasurementBridgeFailure);
                Log.Warn(ex, "Failed to record measurement for instrument type: {0}", state?.GetType()?.Name ?? "unknown");
            }
        }

        private static KeyValuePair<string, object>[] ToArray(ReadOnlySpan<KeyValuePair<string, object>> tags)
        {
            if (tags.Length == 0)
            {
                return Array.Empty<KeyValuePair<string, object>>();
            }
            var arr = new KeyValuePair<string, object>[tags.Length];
            for (int i = 0; i < tags.Length; i++)
            {
                arr[i] = tags[i];
            }
            return arr;
        }

        public class ObservableInstrumentCacheData
        {
            public Delegate CreateObservableInstrumentDelegate { get; set; }
            public Func<object, Meter, ObservableInstrumentCacheData, Instrument> CreateCallbackAndObservableInstrumentDelegate { get; set; }
            public Func<object, IEnumerable> ObserveMethodDelegate { get; set; }
        }
    }
}
